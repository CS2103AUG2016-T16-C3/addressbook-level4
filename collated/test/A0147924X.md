# A0147924X
###### /java/guitests/AddCommandTest.java
``` java
public class AddCommandTest extends TaskManagerGuiTest {

    @Test
    public void add() {
        //add one task
        TestTask[] currentList = td.getTypicalTasks();
        TestTask taskToAdd = td.hotel;
        assertAddSuccess(3, taskToAdd, currentList);
        currentList = TestUtil.addTasksToList(3, currentList, taskToAdd);

        //add another task
        taskToAdd = td.india;
        assertAddSuccess(3, taskToAdd, currentList);
        currentList = TestUtil.addTasksToList(3, currentList, taskToAdd);

        //add duplicate task
        commandBox.runCommand(td.hotel.getAddCommand());
        assertResultMessage(AddCommand.MESSAGE_DUPLICATE_TASK);
        assertTrue(taskListPanel.isListMatching(currentList));

        //add to empty list
        commandBox.runCommand("clear");
        assertAddSuccess(0, td.alpha);

        //invalid command
        commandBox.runCommand("helps Johnny");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
    }
    
    /**
     * Asserts that the add command worked
     * @param indexToInsert Index at which new task should be inserted into the current list
     * @param taskToAdd The task which should be added to the current list
     * @param currentList Current task list to check panel list against
     */
    private void assertAddSuccess(int indexToInsert, TestTask taskToAdd, TestTask... currentList) {
        commandBox.runCommand(taskToAdd.getAddCommand());

        //confirm the new card contains the right data
        TaskCardHandle addedCard = taskListPanel.navigateToTask(taskToAdd.getDesc().get().getValue());
        assertMatching(taskToAdd, addedCard);

        //confirm the list now contains all previous tasks plus the new task
        TestTask[] expectedList = TestUtil.addTasksToList(indexToInsert, currentList, taskToAdd);
        
        assertTrue(taskListPanel.isListMatching(expectedList));
    }

}
```
###### /java/guitests/DoneCommandTest.java
``` java
public class DoneCommandTest extends TaskManagerGuiTest {

    @Test
    public void done() throws IllegalValueException {
    	TestTask[] currentList = td.getTypicalTasks();
        TestTask taskToMark = td.charlie;
        TestTask markedTask = markAsDone(taskToMark);
        assertDoneSuccess(3, 6, markedTask, currentList);
        
        // propagate changes to current list
        currentList = TestUtil.addTasksToList(TestUtil.removeTaskFromList(currentList, 3), markedTask);
        
        // mark another as done
        TestTask taskToMark1 = td.alpha;
        TestTask markedTask1 = markAsDone(taskToMark1);
        assertDoneSuccess(1, 5, markedTask1, currentList);
        
        // invalid index
        commandBox.runCommand("done " + (currentList.length + 1));
        assertResultMessage("The task index provided is invalid");
    }
    
    /**
     * Marks a task as done
     * @param taskToMark The task which should be marked
     * @return Marked task
     * @throws IllegalValueException
     */
    private TestTask markAsDone(TestTask taskToMark) throws IllegalValueException {
    	HashMap<TaskProperties, Optional<TaskProperty>> newProps = 
                taskToMark.getProperties();
        
        newProps.put(TaskProperties.DONE, Optional.of(new Done("Yes")));
        return new TestTask(newProps);
    }
    
    /**
     * Asserts that the done command worked
     * @param index Index to mark as done
     * @param indexToInsert Index at which to insert the marked task in the current list
     * @param markedTask The marked task which will be inserted into the current list
     * @param currentList Current task list to check panel list against 
     */
    private void assertDoneSuccess(int index, int indexToInsert,
    							   TestTask markedTask, TestTask... currentList) {
        commandBox.runCommand(String.format("done %1$s", index));
        
        TaskCardHandle addedCard = taskListPanel.navigateToTask(markedTask.getDesc().get().getValue());
        assertMatching(markedTask, addedCard);
        
        TestTask[] expectedList = TestUtil.addTasksToList(indexToInsert, TestUtil.removeTaskFromList(currentList, index), markedTask);
        assertTrue(taskListPanel.isListMatching(expectedList));
        
        assertResultMessage(String.format(DoneCommand.MESSAGE_SUCCESS, markedTask));
    }
}
```
###### /java/guitests/EditCommandTest.java
``` java
public class EditCommandTest extends TaskManagerGuiTest {
    @Test
    public void edit() throws IllegalValueException {
        TestTask[] currentList = td.getTypicalTasks();
        
        TestTask taskToEdit = td.beta;
        TestTask editedTask = editTaskWithProperty(taskToEdit, TaskProperties.DESC, new Desc("Dinner with Guinevere"));
        assertEditSuccess("edit %1$s Dinner with Guinevere", 2, 2, editedTask, currentList);
        
        currentList = TestUtil.addTasksToList(2, TestUtil.removeTaskFromList(currentList, 2), editedTask);
        
        TestTask editedTask1 = editTaskWithProperty(editedTask, TaskProperties.VENUE, new Venue("Avalon"));
        assertEditSuccess("edit %1$s venue Avalon", 3, 2, editedTask1, currentList);
        
        // invalid index
        commandBox.runCommand("edit " + (currentList.length + 1) + " Some Description");
        assertResultMessage("The task index provided is invalid");
    }
    
    /**
     * Edits a task to change a certain property
     * @param taskToEdit The task which should be edited
     * @param property The property of the task to edit
     * @param value The new value for this property
     * @return Edited task
     */
    private TestTask editTaskWithProperty(TestTask taskToEdit, TaskProperties property, TaskProperty value) {
    	HashMap<TaskProperties, Optional<TaskProperty>> newProps = 
                taskToEdit.getProperties();
        
        newProps.put(property, Optional.of(value));
        
        return new TestTask(newProps);
    }
    
    /**
     * Asserts that the edit command worked
     * @param editCommand A string representing the command to run
     * @param index The index of the task to be edited
     * @param indexToInsert Index at which edited task should be inserted into the current list
     * @param editedTask The edited task Current task list to check panel list against
     * @param currentList
     */
    private void assertEditSuccess(String editCommand, int index, int indexToInsert,
    							   TestTask editedTask, TestTask... currentList) {
        commandBox.runCommand(String.format(editCommand, index));
        
        TaskCardHandle editedCard = taskListPanel.navigateToTask(editedTask.getDesc().get().getValue());
        assertMatching(editedTask, editedCard);
        
        TestTask[] expectedList = TestUtil.addTasksToList(indexToInsert, TestUtil.removeTaskFromList(currentList, index), editedTask);
        assertTrue(taskListPanel.isListMatching(expectedList));
        
        assertResultMessage(String.format(EditCommand.MESSAGE_SUCCESS, editedTask.getAsPrettyText()));
    }
}
```
###### /java/guitests/SortCommandTest.java
``` java
public class SortCommandTest extends TaskManagerGuiTest {
	
	@Test
	public void sort() {
		assertSortSuccess(true);
		
		TestTask taskToAdd = td.hotel;
		commandBox.runCommand(taskToAdd.getAddCommand());
        
        assertSortSuccess(false);
        
        commandBox.runCommand("find CS2101");
        assertSortSuccess(true);
	}
	
	/**
	 * Asserts that the sort command worked
	 * @param shouldRunSortCommand Whether the sort command should be run or not
	 */
	private void assertSortSuccess(boolean shouldRunSortCommand) {
        if (shouldRunSortCommand) {
        	commandBox.runCommand("sort");
		}
        
        Comparator<? super ReadOnlyTask> priorityComparator = (t1, t2) -> t1.compareProperty(t2, TaskProperties.PRIORITY);
        
        assertTrue(isSorted(priorityComparator, taskListPanel.getListView().getItems()));
        
        if (shouldRunSortCommand) {
        	assertResultMessage(SortCommand.MESSAGE_SUCCESS);
		}
    }
	
	/**
	 * Uses a comparator to check whether a given list is sorted or not
	 * @param comparator The comparator which decides ordering of the tasks
	 * @param listToCheck The list which will be checked
	 * @return True if list is sorted, else False
	 */
	private boolean isSorted(Comparator<? super ReadOnlyTask> comparator, ObservableList<ReadOnlyTask> listToCheck) {
		for (int i = 1; i < listToCheck.size(); i++) {
			if (comparator.compare(listToCheck.get(i - 1), listToCheck.get(i)) > 0) {
				return false;
			}
		}
		return true;
	}
}
```
###### /java/guitests/StorageCommandTest.java
``` java
public class StorageCommandTest extends TaskManagerGuiTest {
	@Test
	public void storage() throws IOException, InterruptedException {
		String wrongExtensionFilePath = "WrongExtension";
		commandBox.runCommand("storage " + wrongExtensionFilePath);
		assertResultMessage(StorageCommand.MESSAGE_WRONG_EXTENSION);
		
		String unWriteableFilePath = TestUtil.getFilePathInSandboxFolder("unwritable.xml");
		File unWriteableFile = new File(unWriteableFilePath);
		File unWriteableFolder = new File(unWriteableFilePath).getParentFile();
		Thread.sleep(500);
		unWriteableFolder.setWritable(false);

		Thread.sleep(500);
		commandBox.runCommand("storage " + unWriteableFilePath);
		assertResultMessage(StorageCommand.MESSAGE_NO_PERMISSION);

		Thread.sleep(300);
		if (!System.getProperty("os.name").startsWith("Windows")) {
			// Test fails on windows, cannot restrict access to folders
			commandBox.runCommand("storage " + unWriteableFilePath);
			assertResultMessage(StorageCommand.MESSAGE_NO_PERMISSION);
		}
		
		unWriteableFolder.setWritable(true);
		Thread.sleep(300);
		unWriteableFile.createNewFile();
		Thread.sleep(300);
		unWriteableFolder.setWritable(false);
		Thread.sleep(300);
		if (!System.getProperty("os.name").startsWith("Windows")) {
			// Test fails on windows, cannot restrict access to folders
			commandBox.runCommand("storage " + unWriteableFilePath);
			assertResultMessage(StorageCommand.MESSAGE_ALREADY_EXISTS_NO_OVERWRITE);
		}
		
		unWriteableFolder.setWritable(true);
		Thread.sleep(300);
		unWriteableFile.delete();
		Thread.sleep(300);
		
		String alreadyExistsFilePath = TestApp.SAVE_LOCATION_FOR_TESTING;
		commandBox.runCommand("storage " + alreadyExistsFilePath);
		assertResultMessage(String.format(StorageCommand.MESSAGE_ALREADY_EXISTS_SUCCESS, alreadyExistsFilePath));
		
		String newFilePath = TestUtil.getFilePathInSandboxFolder("newFile.xml");
		File newFile = new File(newFilePath);
		newFile.delete();
		Thread.sleep(300);
		commandBox.runCommand("storage " + newFilePath);
		assertResultMessage(String.format(StorageCommand.MESSAGE_SUCCESS, newFilePath));
		
		String throwsNullExceptionPath = "taskmanager.xml";
		commandBox.runCommand("storage " + throwsNullExceptionPath);
		assertResultMessage(StorageCommand.MESSAGE_NO_PERMISSION);

		String throwsNullExceptionOverwritePath = "taskninja.xml";
		File throwsNullExceptionOverwriteFile = new File(throwsNullExceptionOverwritePath);
		throwsNullExceptionOverwriteFile.createNewFile();
		Thread.sleep(300);
		commandBox.runCommand("storage " + throwsNullExceptionOverwritePath);
		assertResultMessage(StorageCommand.MESSAGE_ALREADY_EXISTS_NO_OVERWRITE);
		throwsNullExceptionOverwriteFile.delete();
		Thread.sleep(300);
		
		String resetFilePath = "data/taskmanager.xml";
		commandBox.runCommand("storage " + resetFilePath); // Reset storage location back to default
	}
}
```
###### /java/guitests/UnSortCommandTest.java
``` java
public class UnSortCommandTest extends TaskManagerGuiTest {
	
	@Test
	public void unsort() {
		assertUnSortSuccess(false);
		
		TestTask taskToAdd = td.hotel;
		commandBox.runCommand(taskToAdd.getAddCommand());
        
        assertUnSortSuccess(false);
        
        commandBox.runCommand("done 1");
        assertUnSortSuccess(false);
        
        commandBox.runCommand("sort");
        assertUnSortSuccess(true);
	}
	
	/**
	 * Asserts that the unsort command worked
	 * @param shouldRunUnSortCommand Whether the unsort command should be run or not
	 */
	private void assertUnSortSuccess(boolean shouldRunUnSortCommand) {
        if (shouldRunUnSortCommand) {
        	commandBox.runCommand("unsort");
		}
        
        Comparator<? super ReadOnlyTask> doneComparator = (t1, t2) -> t1.compareProperty(t2, TaskProperties.DONE);
        
        assertTrue(isSorted(doneComparator, taskListPanel.getListView().getItems()));
        
        if (shouldRunUnSortCommand) {
        	assertResultMessage(UnSortCommand.MESSAGE_SUCCESS);
		}
    }
	
	/**
	 * Uses a comparator to check whether a given list is sorted or not
	 * @param comparator The comparator which decides ordering of the tasks
	 * @param listToCheck The list which will be checked
	 * @return True if list is sorted, else False
	 */
	private boolean isSorted(Comparator<? super ReadOnlyTask> comparator, ObservableList<ReadOnlyTask> listToCheck) {
		for (int i = 1; i < listToCheck.size(); i++) {
			if (comparator.compare(listToCheck.get(i - 1), listToCheck.get(i)) > 0) {
				return false;
			}
		}
		return true;
	}
}
```
###### /java/seedu/manager/logic/LogicManagerTest.java
``` java
    @Test
    public void execute_helpExtraArgs_errorMessageShown() throws Exception {
    	assertCommandBehavior("help abc abc", HelpCommand.MESSAGE_WRONG_NUM_ARGS);
    }
    
    @Test
    public void execute_helpForNonexistentCommand_errorMessageShown() throws Exception {
    	assertCommandBehavior("help abc", HelpCommand.MESSAGE_WRONG_HELP_COMMAND);
    }

    @Test
    public void execute_helpNoArgs_successful() throws Exception {
        assertCommandBehavior("help", HelpCommand.SHOWING_HELP_MESSAGE);
        assertTrue(helpShown);
    }
    
    @Test
    public void execute_helpForCommand_successful() throws Exception {
    	assertCommandBehavior("help add", AddCommand.MESSAGE_USAGE + "\nAlias: add");
    	assertCommandBehavior("help priority", HelpCommand.MESSAGE_PRIORITY_USAGE + "\nAlias: priority");
    }
    
```
###### /java/seedu/manager/logic/LogicManagerTest.java
``` java
    @Test
    public void execute_sort_successful() throws Exception {
    	TestDataHelper helper = new TestDataHelper();
    	model.addTask(helper.generateTask(1));
    	model.addTask(helper.generateTask(2));
    	model.addTask(helper.generateTask(3));
    	
    	TaskManager expectedTM = new TaskManager();
        expectedTM.addTask(helper.generateTask(1));
        expectedTM.addTask(helper.generateTask(2));
        expectedTM.addTask(helper.generateTask(3));
        
        List<ReadOnlyTask> expectedList = new ArrayList<>(expectedTM.getTaskList());
        expectedList.sort((t1, t2) -> t1.compareProperty(t2, TaskProperties.PRIORITY));
        
        assertCommandBehavior("sort", SortCommand.MESSAGE_SUCCESS, expectedTM, expectedList);
    }
    
    
    @Test
    public void execute_add_invalidTaskData() throws Exception {
        assertCommandBehavior(
                "add Dinner with Lancelot venue Acceptable Venue priority wrong", Priority.MESSAGE_PRIORITY_CONSTRAINTS);
        assertCommandBehavior(
                "add venue No Description priority low", AddCommand.MESSAGE_USAGE);
    }

    @Test
    public void execute_addOnlyDesc_successful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.guinevere();
        TaskManager expectedTM = new TaskManager();
        expectedTM.addTask(toBeAdded);

        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeAdded),
                String.format(AddCommand.MESSAGE_SUCCESS, toBeAdded),
                expectedTM,
                expectedTM.getTaskList());
    }
    
    @Test
    public void execute_addDescContainsKeyword_successful() throws Exception {
    	// setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.morgana();
        TaskManager expectedTM = new TaskManager();
        expectedTM.addTask(toBeAdded);
        
        assertCommandBehavior(helper.generateAddCommand(toBeAdded),
                String.format(AddCommand.MESSAGE_SUCCESS, toBeAdded),
                expectedTM,
                expectedTM.getTaskList());
        assertEquals(0, targetedTaskJumpIndex);
    }
    
    @Test
    public void execute_addContainsEscapedKeyword_successful() throws Exception {
    	// setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.challenge();
        TaskManager expectedTM = new TaskManager();
        expectedTM.addTask(toBeAdded);
        
        assertCommandBehavior(
        		"add Come 'at' me venue Battlefield priority high",
                String.format(AddCommand.MESSAGE_SUCCESS, toBeAdded),
                expectedTM,
                expectedTM.getTaskList());
        assertEquals(0, targetedTaskJumpIndex);
        
        toBeAdded = helper.canoodle();
        expectedTM.addTask(toBeAdded);
        
        assertCommandBehavior(
        		"add Secret rendezvous venue 'by' the wall",
                String.format(AddCommand.MESSAGE_SUCCESS, toBeAdded),
                expectedTM,
                expectedTM.getTaskList());
        assertEquals(1, targetedTaskJumpIndex);
    }
    
    @Test
    public void execute_add_successful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.lancelot();
        TaskManager expectedTM = new TaskManager();
        expectedTM.addTask(toBeAdded);

        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeAdded),
                String.format(AddCommand.MESSAGE_SUCCESS, toBeAdded.getAsPrettyText()),
                expectedTM,
                expectedTM.getTaskList());
        assertEquals(0, targetedTaskJumpIndex);
        
        
        toBeAdded = helper.guinevere();
        expectedTM.addTask(toBeAdded);
        
        assertCommandBehavior(helper.generateAddCommand(toBeAdded),
                String.format(AddCommand.MESSAGE_SUCCESS, toBeAdded.getAsPrettyText()),
                expectedTM,
                expectedTM.getTaskList());
        assertEquals(1, targetedTaskJumpIndex);
    }

    @Test
    public void execute_addDuplicate_notAllowed() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.guinevere();
        TaskManager expectedTM = new TaskManager();
        expectedTM.addTask(toBeAdded);

        // setup starting state
        model.addTask(toBeAdded); // task already in internal task manager

        // execute command and verify result
        assertCommandBehavior(
                helper.generateAddCommand(toBeAdded),
                AddCommand.MESSAGE_DUPLICATE_TASK,
                expectedTM,
                expectedTM.getTaskList());
    }
    
    @Test
    public void execute_addAfterSorting_successful() throws Exception {
    	TestDataHelper helper = new TestDataHelper();
    	Task toBeAdded = helper.guinevere();
    	helper.addToModel(model, 3);
    	
    	TaskManager expectedTM = new TaskManager();
    	helper.addToTaskManager(expectedTM, 3);
        expectedTM.addTask(toBeAdded);
        
        List<ReadOnlyTask> expectedList = new ArrayList<>(expectedTM.getTaskList());
        expectedList.sort((t1, t2) -> t1.compareProperty(t2, TaskProperties.PRIORITY));
        
        logic.execute("sort");
        
        assertCommandBehavior(
                helper.generateAddCommand(toBeAdded),
                String.format(AddCommand.MESSAGE_SUCCESS, toBeAdded.getAsPrettyText()),
                expectedTM,
                expectedList);
        
        assertEquals(expectedList.indexOf(toBeAdded), targetedTaskJumpIndex);
    }
    
    @Test
    public void execute_editInvalidArgsFormat_errorMessageShown() throws Exception {
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE);
        assertIncorrectIndexFormatBehaviorForCommand("edit", expectedMessage);
    }

    @Test
    public void execute_editIndexInvalid_errorMessageShown() throws Exception {
        String expectedMessage = Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX;
        assertCommandBehavior("edit 52 Dinner with Arthur", expectedMessage);
        assertCommandBehavior("edit 10 Dinner with Arthur", expectedMessage);
    }

    @Test
    public void execute_editInvalidFromToFormat_errorMessage() throws Exception {
        String expectedMessage = ExtensionParser.EXTENSION_FROM_TO_INVALID_FORMAT;
        assertCommandBehavior("edit 1 from 7:30-8:30", expectedMessage);
        assertCommandBehavior("edit 1 from 7:30", expectedMessage);
    }
    
    @Test
    public void execute_editDuplicateParams_errorMessage() throws Exception {
    	TestDataHelper helper = new TestDataHelper();
        TaskManager expectedTM = new TaskManager();
        Task toBeEdited = helper.guinevere();
        model.addTask(toBeEdited);
        expectedTM.addTask(toBeEdited);
        
        String editCommand = "edit 1 Picnic with Guinevere";
        
    	assertCommandBehavior(
                editCommand,
                String.format(EditCommand.MESSAGE_DUPLICATE_PARAMS, toBeEdited),
                expectedTM,
                expectedTM.getTaskList()
        );
    }

    @Test
    public void execute_edit_successful() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        Task toBeEdited = helper.lancelot();
        Task newTask = editTaskWithProperty(toBeEdited, TaskProperties.DESC, "Dinner with Guinevere");
        
        model.addTask(toBeEdited);
        model.addTask(helper.morgana());
        TaskManager expectedTM = new TaskManager();
        expectedTM.addTask(helper.morgana());
        expectedTM.addTask(newTask);

        String editCommand = "edit 1 Dinner with Guinevere";

        assertCommandBehavior(
                editCommand,
                String.format(EditCommand.MESSAGE_SUCCESS, newTask.getAsPrettyText()),
                expectedTM,
                expectedTM.getTaskList()
        );
        
        assertEquals(1, targetedTaskJumpIndex);
        
        
        Task newTask1 = editTaskWithProperty(newTask, TaskProperties.DESC, "Dinner with Lancelot");
        newTask1 = editTaskWithProperty(newTask1, TaskProperties.VENUE, "Avalon");

        expectedTM.removeTask(newTask);
        expectedTM.addTask(newTask1);

        String editCommand1 = "edit 2 Dinner with Lancelot venue Avalon";

        assertCommandBehavior(
                editCommand1,
                String.format(EditCommand.MESSAGE_SUCCESS, newTask1.getAsPrettyText()),
                expectedTM,
                expectedTM.getTaskList()
        );
        
        assertEquals(1, targetedTaskJumpIndex);
        
        
        Task newTask2 = editTaskWithProperty(newTask1, TaskProperties.STARTTIME, "7:30pm");
        newTask2 = editTaskWithProperty(newTask2, TaskProperties.ENDTIME, "8:50pm");
        newTask2 = editTaskWithProperty(newTask2, TaskProperties.PRIORITY, "low");

        expectedTM.removeTask(newTask1);
        expectedTM.addTask(newTask2);

        String editCommand2 = "edit 2 from 7:30pm to 8:50pm priority low";

        assertCommandBehavior(
                editCommand2,
                String.format(EditCommand.MESSAGE_SUCCESS, newTask2.getAsPrettyText()),
                expectedTM,
                expectedTM.getTaskList()
        );
        
        assertEquals(1, targetedTaskJumpIndex);
    }
    
    /**
     * Edit a certain property of a given task
     * @param taskToEdit Task that will be edited
     * @param property The property that will be edited
     * @param value The new value of the property
     * @return A new task with the edited property
     * @throws IllegalValueException
     */
    private Task editTaskWithProperty(Task taskToEdit, TaskProperties property, String value)
    		throws IllegalValueException {
    	HashMap<TaskProperties, Optional<String>> newProps = 
                taskToEdit.getPropertiesAsStrings();
        
        newProps.put(property, Optional.of(value));
        
        return new Task(newProps);
    }
    
    @Test
    public void execute_editAfterSorting_successful() throws Exception {
    	TestDataHelper helper = new TestDataHelper();
        Task toBeEdited = helper.lancelot();
    	model.addTask(helper.generateTask(2));
    	model.addTask(helper.generateTask(3));
    	model.addTask(toBeEdited);
    	
    	logic.execute("sort");
    	
    	TaskManager expectedTM = new TaskManager();
        expectedTM.addTask(helper.generateTask(2));
        expectedTM.addTask(helper.generateTask(3));
        
        HashMap<TaskProperties, Optional<String>> newProps = 
                toBeEdited.getPropertiesAsStrings();
        newProps.put(TaskProperties.DESC, Optional.of("Dinner with Guinevere"));
        
        Task newTask = new Task(newProps);
        expectedTM.addTask(newTask);

        String editCommand = "edit 2 Dinner with Guinevere";
        
        List<ReadOnlyTask> expectedList = new ArrayList<>(expectedTM.getTaskList());
        expectedList.sort((t1, t2) -> t1.compareProperty(t2, TaskProperties.PRIORITY));

        assertCommandBehavior(
                editCommand,
                String.format(EditCommand.MESSAGE_SUCCESS, newTask.getAsPrettyText()),
                expectedTM,
                expectedList
        );
        
        assertEquals(expectedList.indexOf(newTask), targetedTaskJumpIndex);
    }
    
    
    @Test
    public void execute_doneInvalidArgsFormat_errorMessageShown() throws Exception {
    	String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, DoneCommand.MESSAGE_USAGE);
    	assertIncorrectIndexFormatBehaviorForCommand("done", expectedMessage);
    }
    
    @Test
    public void execute_doneIndexInvalid_errorMessageShown() throws Exception {
    	String expectedMessage = Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX;
        assertCommandBehavior("done 52", expectedMessage);
        assertCommandBehavior("done 10", expectedMessage);
    }
    
    @Test
    public void execute_done_successful() throws Exception {
    	TestDataHelper helper = new TestDataHelper();
    	List<Task> threeTasks = helper.generateTaskList(3);
    	helper.addToModel(model, threeTasks);
    	TaskManager expectedTM = helper.generateTaskManager(threeTasks);
        
        Task doneTask = editTaskWithProperty(threeTasks.get(1), TaskProperties.DONE, "Yes");
        expectedTM.removeTask(threeTasks.get(1));
        expectedTM.addTask(doneTask);
        
        String doneCommand = "done 2";

        // execute command and verify result
        assertCommandBehavior(doneCommand,
                String.format(DoneCommand.MESSAGE_SUCCESS, doneTask),
                expectedTM,
                expectedTM.getTaskList());
        assertEquals(2, targetedTaskJumpIndex);
    }

```
###### /java/seedu/manager/logic/LogicManagerTest.java
``` java
    @Test
    public void execute_findThenSort_successful() throws Exception {
    	TestDataHelper helper = new TestDataHelper();
        Task p1 = helper.generateTaskWithDesc("bla bla bla bla");
        Task p2 = helper.generateTaskWithDesc("bla KEY bla bceofeia");
        Task p3 = helper.generateTaskWithDesc("key key");
        Task p4 = helper.generateTaskWithDesc("KEy sduauo");

        List<Task> fourTasks = helper.generateTaskList(p3, p1, p4, p2);
        TaskManager expectedTM = helper.generateTaskManager(fourTasks);
        helper.addToModel(model, fourTasks);
        
        
        List<Task> expectedList = helper.generateTaskList(p3, p4, p2);

        assertCommandBehavior("find KEY",
                Command.getMessageForTaskListShownSummary(expectedList.size()),
                expectedTM,
                expectedList);
        
        expectedList.sort((t1, t2) -> t1.compareProperty(t2, TaskProperties.PRIORITY));
        
        assertCommandBehavior("sort", SortCommand.MESSAGE_SUCCESS, expectedTM, expectedList);
    }
    
```
###### /java/seedu/manager/logic/LogicManagerTest.java
``` java
    @Test
    public void execute_findTag_successful() throws Exception {
    	TestDataHelper helper = new TestDataHelper();
        Task p1 = helper.generateTaskWithTagAndDesc("Kill Mordred", "Violent");
        Task p2 = helper.guinevere();
        Task p3 = helper.lancelot();
        Task p4 = helper.morgana();
        Task p5 = helper.generateTaskWithTagAndDesc("Elope with Guinevere", "Home-wrecking");
        
        List<Task> fiveTasks = helper.generateTaskList(p5, p3, p1, p4, p2);
        TaskManager expectedTM = helper.generateTaskManager(fiveTasks);
        helper.addToModel(model, fiveTasks);
        model.addTag(new Tag("Home-wrecking"));
        model.addTag(new Tag("Violent"));
        
        List<Task> expectedList = helper.generateTaskList(p1);
        
        assertCommandBehavior("find tag Violent",
                Command.getMessageForTaskListShownSummary(expectedList.size()),
                expectedTM,
                expectedList);
        assertEquals(1, targetedTagJumpIndex);
    }
    
```
###### /java/seedu/manager/logic/LogicManagerTest.java
``` java
    @Test
    public void execute_alias_wrongNumberOfArgs() throws Exception {
        assertCommandBehavior("alias", AliasCommand.MESSAGE_WRONG_NUM_ARGS);
        assertCommandBehavior("alias add", AliasCommand.MESSAGE_WRONG_NUM_ARGS);
        assertCommandBehavior("alias add + -", AliasCommand.MESSAGE_WRONG_NUM_ARGS);
    }
    
    @Test
    public void execute_alias_doesNotExist() throws Exception {
        assertCommandBehavior("alias - +", AliasCommand.MESSAGE_NO_MATCH);
    }
    
    @Test
    public void execute_alias_alreadyTaken() throws Exception {
        assertCommandBehavior("alias add +", String.format(AliasCommand.MESSAGE_SUCCESS, "add", "+"));
        assertCommandBehavior("alias edit +", String.format(AliasCommand.MESSAGE_ALIAS_TAKEN, Commands.ADD));
    }
    
    @Test
    public void execute_alias_successful() throws Exception {
        assertCommandBehavior("alias add +", String.format(AliasCommand.MESSAGE_SUCCESS, "add", "+"));
        assertCommandBehavior("help add", AddCommand.MESSAGE_USAGE + "\nAlias: +");
        
        TestDataHelper helper = new TestDataHelper();
        TaskManager expectedTM = new TaskManager();
        Task toBeAdded = helper.lancelot();
        expectedTM.addTask(toBeAdded);

        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommandWithAlias(toBeAdded, "+"),
                String.format(AddCommand.MESSAGE_SUCCESS, toBeAdded.getAsPrettyText()),
                expectedTM,
                expectedTM.getTaskList());
        assertEquals(0, targetedTaskJumpIndex);
        
        
        assertCommandBehavior("alias delete -",
                String.format(AliasCommand.MESSAGE_SUCCESS, "delete", "-"),
                expectedTM,
                expectedTM.getTaskList());
        expectedTM.removeTask(toBeAdded);
        
        assertCommandBehavior("- 1",
                String.format(DeleteCommand.MESSAGE_SUCCESS, toBeAdded.getAsPrettyText()),
                expectedTM,
                expectedTM.getTaskList());
        
        
        assertCommandBehavior("alias priority p",
                String.format(AliasCommand.MESSAGE_SUCCESS, "priority", "p"),
                expectedTM,
                expectedTM.getTaskList());
        
        toBeAdded = helper.morgana();
        expectedTM.addTask(toBeAdded);
        
        assertCommandBehavior(helper.generateAddCommandWithAlias(toBeAdded, "+").replace("priority", "p"),
                String.format(AddCommand.MESSAGE_SUCCESS, toBeAdded.getAsPrettyText()),
                expectedTM,
                expectedTM.getTaskList());
        assertEquals(0, targetedTaskJumpIndex);
        
        // cleanup
        logic.execute("alias + add");
        logic.execute("alias - delete");
        logic.execute("alias p priority");
    }
    
    /**
     * A utility class to generate test data.
     */
    class TestDataHelper{

        Task guinevere() throws Exception {
            return new Task("Picnic with Guinevere", "", "", "", "", "", "");
        }


        Task lancelot() throws Exception {
            return new Task("Joust with Lancelot", "Avalon", "med", "7:30", "8:30", "", "");
        }
        
        Task morgana() throws Exception {
        	return new Task("Flatten Morgana", "Camelot", "high", "", "", "", "");
        }
        
        Task challenge() throws Exception {
        	return new Task("Come at me", "Battlefield", "high", "", "", "", "");
        }
        
        Task canoodle() throws Exception {
        	return new Task("Secret rendezvous", "by the wall", "", "", "", "", "");
        }

        /**
         * Generates a valid task using the given seed.
         * Running this function with the same parameter values guarantees the returned task will have the same state.
         * Each unique seed will generate a unique Task object.
         *
         * @param seed used to generate the task data field values
         */
        Task generateTask(int seed) throws Exception {
            return new Task(
                    "Task " + seed,
                    "" + Math.abs(seed),
                    new String[] {"low", "med", "high"}[seed % 3],
                    (Math.abs(seed) % 12 + 1) + ":00",
                    (Math.abs(seed) % 12 + 1) + ":00", 
                    "",
                    ""
            );
        }
        
        /**
         * Generated the add command given a task and alias for the add command
         * @param task Task for which the add command will be generated
         * @param alias Alias of the add command
         * @return The generated add command
         */
        String generateAddCommandWithAlias(Task task, String alias) {
        	StringBuffer cmd = new StringBuffer();

            cmd.append(alias + " ");

            cmd.append(task.getDesc().get().toString());
            if (task.getVenue().isPresent()) {
                cmd.append(" venue ").append(task.getVenue().get().toString());
            }
            if (task.getPriority().isPresent()) {
                cmd.append(" priority ").append(task.getPriority().get().toString());
            }
            if (task.getStartTime().isPresent()) {
                cmd.append(" from ").append(task.getStartTime().get().toString());
            }
            if (task.getEndTime().isPresent()) {
                cmd.append(" to ").append(task.getEndTime().get().toString());
            }
            if (task.getTag().isPresent()) {
                cmd.append(" tag ").append(task.getTag().get().toString());
            }

            return cmd.toString();
        }

        /**
         * Generates the add command given a task (assumes alias is add)"
         * @param task The task for which add command will be generated
         * @return The generated add command
         */
        String generateAddCommand(Task task) {
        	return generateAddCommandWithAlias(task, "add");
        }
        
```
###### /java/seedu/manager/logic/LogicManagerTest.java
``` java
        /**
         * Generates a Task object with given tag. Other fields will have some dummy values.
         * @param desc Description for the task
         * @param tag Tag for the task
         * @return Task with the given parameters
         * @throws Exception
         */
        Task generateTaskWithTagAndDesc(String desc, String tag) throws Exception {
            return new Task(
                    desc,
                    "Camelot",
                    "med",
                    "4.30am",
                    "7am",
                    "",
                    tag
            );
        }
    }
}
```
###### /java/seedu/manager/logic/parser/ExtensionParserTest.java
``` java
public class ExtensionParserTest {
    private ExtensionParser extensionParser;
    @Before
    public void init_ext_parser() {
        extensionParser = new ExtensionParser((new UserPrefs()).getExtensionsWords());
    }
    
    @Rule
    public ExpectedException expectedEx = ExpectedException.none();
    
    @Test
    public void parse_invalid_duplicateError() throws IllegalValueException {
    	expectedEx.expect(IllegalValueException.class);
    	expectedEx.expectMessage(String.format(ExtensionParser.EXTENSION_DUPLICATES, "venue"));
    	extensionParser.getTaskProperties("Dinner with Lancelot venue Avalon venue Round Table");    	
        
    	expectedEx.expectMessage(String.format(ExtensionParser.EXTENSION_DUPLICATES, "priority"));
        extensionParser.getTaskProperties("Dinner with Lancelot venue Avalon priority high priority low");
        
        expectedEx.expectMessage(String.format(ExtensionParser.EXTENSION_DUPLICATES, "at"));
        extensionParser.getTaskProperties("Dinner with Lancelot priority high at 8:30 at 9:00");
    }
    
    @Test
    public void parse_invalid_fromToFormatError() throws IllegalValueException {
    	expectedEx.expect(IllegalValueException.class);
    	expectedEx.expectMessage(ExtensionParser.EXTENSION_FROM_TO_INVALID_FORMAT);
    	extensionParser.getTaskProperties("Dinner with Lancelot from 8:30");
        
    	expectedEx.expectMessage(ExtensionParser.EXTENSION_FROM_TO_INVALID_FORMAT);
        extensionParser.getTaskProperties("Dinner with Lancelot from 8:30to 9:30");

        expectedEx.expectMessage(ExtensionParser.EXTENSION_FROM_TO_INVALID_FORMAT);
        extensionParser.getTaskProperties("Dinner with Lancelot from 8:30 to9:30");
    }
    
    @Test
    public void parse_allExt_successful() throws IllegalValueException {
        assertEquals(
                constructProperties("Dinner with Lancelot", "Avalon", "high", "7:30", "8:30"),
                extensionParser.getTaskProperties("Dinner with Lancelot venue Avalon priority high from 7:30 to 8:30")
                );
    }
    
    @Test 
    public void parse_ext_successful() throws IllegalValueException {
        assertEquals(
                constructProperties("Dinner with Arthur", "Round Table", "high", "", ""),
                extensionParser.getTaskProperties("Dinner with Arthur venue Round Table priority high")
                );
        assertEquals(
                constructProperties("Dinner with Arthur", "", "low", "7:30pm", ""),
                extensionParser.getTaskProperties("Dinner with Arthur priority low at 7:30pm")
                );
        assertEquals(
                constructProperties("Dinner with Arthur", "", "low", "", "8:30pm"),
                extensionParser.getTaskProperties("Dinner with Arthur priority low by 8:30pm")
                );
        assertEquals(
                constructProperties("Dinner with Arthur", "", "", "7:30pm", "8:30pm"),
                extensionParser.getTaskProperties("Dinner with Arthur from 7:30pm to 8:30pm")
                );
        assertEquals(
                constructProperties("Dinner with Arthur", "", "low", "7:30pm", "8:30pm"),
                extensionParser.getTaskProperties("Dinner with Arthur from 7:30pm to 8:30pm priority low")
                );
    }
    
    @Test
    public void parse_onlyDesc_successful() throws IllegalValueException {
        assertEquals(
                constructProperties("Dinner with Lancelot", "", "", "", ""),
                extensionParser.getTaskProperties("Dinner with Lancelot")
                );
    }
    
    @Test
    public void parse_noDesc_successful() throws IllegalValueException {
        assertEquals(
                constructProperties("", "Avalon", "high", "7:30", "8:30"),
                extensionParser.getTaskProperties("venue Avalon priority high from 7:30 to 8:30")
                );
    }
    
    @Test
    public void parse_extraSpacing_successful() throws IllegalValueException {
        assertEquals(
                constructProperties("Dinner with Lancelot", "Avalon", "high", "7:30", "8:30"),
                extensionParser.getTaskProperties("  Dinner with Lancelot venue Avalon priority high from 7:30 to 8:30")
                );
        assertEquals(
                constructProperties("Dinner with Lancelot", "Avalon", "high", "7:30", "8:30"),
                extensionParser.getTaskProperties("Dinner with Lancelot   venue Avalon priority high from 7:30 to 8:30")
                );
        assertEquals(
                constructProperties("Dinner with Lancelot", "Avalon", "high", "7:30", "8:30"),
                extensionParser.getTaskProperties("Dinner with Lancelot venue Avalon priority high from 7:30 to 8:30  ")
                );
        assertEquals(
                constructProperties("Dinner with Lancelot", "Avalon", "high", "7:30", "8:30"),
                extensionParser.getTaskProperties("Dinner with Lancelot venue Avalon   priority high from 7:30 to 8:30")
                );
        assertEquals(
                constructProperties("Dinner with Lancelot", "Avalon", "high", "7:30", "8:30"),
                extensionParser.getTaskProperties("Dinner with Lancelot venue   Avalon priority high from 7:30  to  8:30")
                );
    }
    
    /**
     * Construct a Hashmap from the given properties. Empty strings get turned into empty Optionals
     * @param desc Task's description
     * @param venue Task's venue
     * @param priority Task's priority
     * @param startTime Task's start time
     * @param endTime Task's end time
     * @return The Hashmap containing all these properties
     * @throws IllegalValueException
     */
    private HashMap<TaskProperties, Optional<String>> constructProperties(
            String desc, String venue, String priority, String startTime, String endTime
            ) throws IllegalValueException {
        HashMap<TaskProperties, Optional<String>> properties = new HashMap<>();
        properties.put(TaskProperties.DESC, desc.equals("") ? Optional.empty() : Optional.of(desc));
        properties.put(TaskProperties.VENUE, venue.equals("") ? Optional.empty() : Optional.of(venue));
        properties.put(TaskProperties.PRIORITY, priority.equals("") ? Optional.empty() : Optional.of(priority));
        properties.put(TaskProperties.STARTTIME, startTime.equals("") ? Optional.empty() : Optional.of(startTime));
        properties.put(TaskProperties.ENDTIME, endTime.equals("") ? Optional.empty() : Optional.of(endTime));
        properties.put(TaskProperties.DONE, Optional.empty());
        properties.put(TaskProperties.TAG, Optional.empty());
        return properties;
    }
}
```
###### /java/seedu/manager/model/TimeTest.java
``` java
public class TimeTest {
	@Test
	public void parseTime_invalid_throwsError() throws IllegalValueException {
		assertInvalidTime("This is not a time");
		assertInvalidTime("123");
		assertInvalidTime("tomorrow and day after tomorrow"); // multiple times
		assertInvalidTime("5:95pm");
		assertInvalidTime("Abc Oct 16 01:00:00 SGT 2100");
		assertInvalidTime("Sat Abc 16 01:00:00 SGT 2100");
		assertInvalidTime("Sat Oct 50 01:00:00 SGT 2100");
		assertInvalidTime("Sat Oct 16 25:00:00 SGT 2100");
		assertInvalidTime("Sat Oct 16 23:61:00 SGT 2100");
		assertInvalidTime("Sat Oct 16 23:00:61 SGT 2100");
		assertInvalidTime("Sat Oct 16 23:00:00 ABC 2100");
		
		// PrettyTime accepts these
		// assertInvalidTime("tomorrow day after tomorrow"); only tomorrow
		// assertInvalidTime("32 Oct"); Tue Oct 01 <time> SGT 2047
	}
	
	@Test
	public void parseTime_compareWithExpected_Succeeds() throws IllegalValueException {
		assertParsedTimeEquals(new StartTime("now"), getCalendar());
		assertParsedTimeEquals(new StartTime("tomorrow"), addDaysToCal(getCalendar(), 1));
		assertParsedTimeEquals(new StartTime("5pm"), setTime(5, 0, false));
		assertParsedTimeEquals(new StartTime("5:30pm tomorrow"), addDaysToCal(setTime(5, 30, false), 1));
		assertParsedTimeEquals(new StartTime("day after tomorrow"), addDaysToCal(getCalendar(), 2));
		assertParsedTimeEquals(new StartTime("3 days later"), addDaysToCal(getCalendar(), 3));
		assertParsedTimeEquals(new StartTime("Sun next week"), setDay(addDaysToCal(getCalendar(), 7), Calendar.SUNDAY));
		assertParsedTimeEquals(new StartTime("day after tomorrow evening"), addDaysToCal(setTime(7, 0, false), 2));
		assertParsedTimeEquals(new StartTime("tonight"), setTime(8, 0, false));
		assertParsedTimeEquals(new StartTime("today noon"), setTime(12, 0, true)); // calendar take 12am to be noon
		
		String timeZone = TimeZone.getDefault().getDisplayName(false, TimeZone.SHORT);
		assertParsedTimeEquals(new StartTime("Sat Oct 16 01:00:00 " + timeZone + " 2100"), setAll(2100, Calendar.OCTOBER, 16, 1, 0, true));
	}
	
	@Rule
    public ExpectedException expectedEx = ExpectedException.none();
	
	/**
	 * Asserts that the time is invalid
	 * @param time Time to be tested
	 * @throws IllegalValueException
	 */
	private void assertInvalidTime(String time) throws IllegalValueException {
		expectedEx.expect(IllegalValueException.class);
		expectedEx.expectMessage(Time.MESSAGE_TIME_CONSTRAINTS);
		new StartTime(time);
	}
	
	/**
	 * Gets a new calendar instance
	 * @return Calendar instance
	 */
	private Calendar getCalendar() {
		Calendar calendar = Calendar.getInstance();
		calendar.setTime(new Date());
		return calendar;
	}
	
	/**
	 * Adds the specified number of days to the calendar
	 * @param calendar Calendar to which days will be added
	 * @param numDays Number of days to add
	 * @return Calendar with days added
	 */
	private Calendar addDaysToCal(Calendar calendar, int numDays) {
		calendar.add(Calendar.DATE, numDays);
		return calendar;
	}
	
	/**
	 * Set hour, minute and part of day in a calendar
	 * @param hour Hour to set
	 * @param minute Minute to set
	 * @param isAM Whether the time is AM or PM
	 * @return Calendar with these properties
	 */
	private Calendar setTime(int hour, int minute, boolean isAM) {
		Calendar calendar = getCalendar();
		calendar.set(Calendar.HOUR, hour);
		calendar.set(Calendar.MINUTE, minute);
		calendar.set(Calendar.SECOND, 0);
		calendar.set(Calendar.AM_PM, isAM ? Calendar.AM : Calendar.PM);
		return calendar;
	}
	
	/**
	 * Sets a certain day of the week in the calendar
	 * @param calendar Calendar in which the day will be set
	 * @param day Day of the week to set
	 * @return Calendar with the day set
	 */
	private Calendar setDay(Calendar calendar, int day) {
		calendar.set(Calendar.DAY_OF_WEEK, day);
		return calendar;
	}
	
	/**
	 * Sets all of year, month, date, hour, minute and AM/PM in a calendar
	 * @param year Year to set
	 * @param month Month to set
	 * @param date Date to set
	 * @param hourOfDay Hour to set
	 * @param minute Minute to set
	 * @param isAM Whether the time is AM or PM
	 * @return Calendar with these properties set
	 */
	private Calendar setAll(int year, int month, int date, int hourOfDay, int minute, boolean isAM) {
		Calendar calendar = setTime(hourOfDay, minute, isAM);
		calendar.set(year, month, date);
		return calendar;
	}
	
	/**
	 * Asserts that the parsed time is the same as the time in the calendar
	 * @param time Parsed time
	 * @param expected Expected time in a calendar object
	 * @throws IllegalValueException
	 */
	private void assertParsedTimeEquals(Time time, Calendar expected) throws IllegalValueException {
		assertEquals(expected.getTime().toString(), time.getValue());
	}
}
```
###### /java/seedu/manager/testutil/TestTask.java
``` java
    public String getAddCommand() {
        StringBuilder sb = new StringBuilder();
        sb.append("add " + this.getDesc().get().getValue() + " ");
        if (this.getVenue().isPresent()) {
            sb.append("venue " + this.getVenue().get().getValue() + " ");
        }
        if (this.getPriority().isPresent()) {
            sb.append("priority " + this.getPriority().get().getValue() + " ");
        }
        if (this.getStartTime().isPresent()) {
            sb.append("at " + this.getStartTime().get().getValue() + " ");
        }
        if (this.getEndTime().isPresent()) {
            sb.append("by " + this.getEndTime().get().getValue() + " ");
        }
        if (this.getTag().isPresent()) {
            sb.append("tag " + this.getTag().get().getValue() + " ");
        }
        return sb.toString();
    }

    @SuppressWarnings("unchecked")
    @Override
    public HashMap<TaskProperties, Optional<TaskProperty>> getProperties() {
        return (HashMap<TaskProperties, Optional<TaskProperty>>) properties.clone();
    }

	@Override
	public HashMap<TaskProperties, Optional<String>> getPropertiesAsStrings() {
		HashMap<TaskProperties, Optional<String>> clone = new HashMap<>();
        for (Entry<TaskProperties, Optional<TaskProperty>> prop : properties.entrySet()) {
            clone.put(prop.getKey(),
            		prop.getValue().isPresent() ? 
            				Optional.of(prop.getValue().get().getValue()) : 
            				Optional.empty());
        }
        return clone;
			
	}
	
	@Override
    public int compareProperty(ReadOnlyTask other, TaskProperties property) {
    	assert other != null;
    	if (!this.properties.get(property).isPresent()) {
			return -1;
		} else {
			HashMap<TaskProperties, Optional<TaskProperty>> otherProps = other.getProperties();
			if (!otherProps.get(property).isPresent()) {
				return -1;
			} else {
				return this.properties.get(property).get().compareTo(otherProps.get(property).get());
			}
		}
    }
	
```
###### /java/seedu/manager/testutil/TestUtil.java
``` java
    /**
     * Inserts tasks into the array of tasks.
     * @param index Index at which to insert the first of the tasks
     * @param tasks An array of tasks
     * @param tasksToAdd The tasks that are to be appended behind the original array.
     * @return The modified array of tasks.
     */
    public static TestTask[] addTasksToList(int index, final TestTask[] tasks, TestTask... tasksToAdd) {
        List<TestTask> listOfTasks = asList(tasks);
        listOfTasks.addAll(index, asList(tasksToAdd));
        return listOfTasks.toArray(new TestTask[listOfTasks.size()]);
    }
    
```
