# A0147924X
###### /java/seedu/manager/commons/core/CommandWord.java
``` java
/**
 * Represents a command in the task manager
 *
 */
public class CommandWord {
	
	public enum Commands {
		ADD("add"), EDIT("edit"), DELETE("delete"), UNDO("undo"), 
		FIND("find"), STORAGE("storage"), CLEAR("clear"), DONE("done"), 
		EXIT("exit"), HELP("help"), LIST("list"), SORT("sort"),
		UNSORT("unsort"), ALIAS("alias"), BY("by"), AT("at"), 
		EVENT("from"), PRIORITY("priority"), TAG("tag"), VENUE("venue");
		
		private String commandRep;
		
		private Commands(String commandRep) {
			this.commandRep = commandRep;
		}
		
		public String toString() {
			return commandRep;
		}
	}
}
```
###### /java/seedu/manager/commons/core/Config.java
``` java
    public Config() {
    	EventsCenter.getInstance().registerHandler(this);
    }
    
```
###### /java/seedu/manager/commons/core/Config.java
``` java
    @Subscribe
    public void handleStorageLocationChangedEvent(StorageLocationChangedEvent event) {
    	setTaskManagerFilePath(event.getFilePath());
    	try {
			ConfigUtil.saveConfig(this, DEFAULT_CONFIG_FILE);
			EventsCenter.getInstance().post(new ConfigFilePathChangedEvent(event.getFilePath()));
		} catch (IOException e) {
			e.printStackTrace();
		}
    }
}
```
###### /java/seedu/manager/commons/events/logic/CommandWordsChangedEvent.java
``` java
/**
 * Indicates that command words have changed
 *
 */
public class CommandWordsChangedEvent extends BaseEvent {

	public CommandWordsChangedEvent() {}
	
	@Override
	public String toString() {
		return this.getClass().getSimpleName();
	}

}
```
###### /java/seedu/manager/commons/events/storage/ConfigFilePathChangedEvent.java
``` java
/**
 * Indicates that the TaskManager Storage location has changed in the Config
 *
 */
public class ConfigFilePathChangedEvent extends BaseEvent {
	private final String filePath;
	
	public ConfigFilePathChangedEvent(String filePath) {
		this.filePath = filePath;
	}
	
	public String getFilePath() {
		return filePath;
	}
	
	@Override
	public String toString() {
		return "Storage location in Config has changed to " + filePath;
	}
}
```
###### /java/seedu/manager/commons/events/storage/StorageLocationChangedEvent.java
``` java
/**
 * Indicates that the storage location has changed
 *
 */
public class StorageLocationChangedEvent extends BaseEvent {
	
	private final String filePath;
	
	public StorageLocationChangedEvent(String filePath) {
		this.filePath = filePath;
	}
	
	public String getFilePath() {
		return filePath;
	}
	
	@Override
	public String toString() {
		return "The storage location has been changed to " + filePath;
	}
}
```
###### /java/seedu/manager/commons/events/storage/UserPrefsChangedEvent.java
``` java
/**
 * Indicates that User Preferences have changed
 *
 */
public class UserPrefsChangedEvent extends BaseEvent {
	
	private UserPrefs userPrefs;
	
	public UserPrefsChangedEvent(UserPrefs userPrefs) {
		this.userPrefs = userPrefs;
	}
	
	public UserPrefs getUserPrefs() {
		return userPrefs;
	}

	@Override
	public String toString() {
		return "User Preferences have changed";
	}

}
```
###### /java/seedu/manager/commons/events/ui/JumpToTagListRequestEvent.java
``` java
/**
 * Indicates a request to jump to a certain tag
 *
 */
public class JumpToTagListRequestEvent extends BaseEvent {

    private final int targetIndex;

    public JumpToTagListRequestEvent(int targetIndex) {
        this.targetIndex = targetIndex;
    }
    
    public int getTargetIndex() {
		return targetIndex;
	}

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### /java/seedu/manager/commons/events/ui/JumpToTaskListRequestEvent.java
``` java
/**
 * Indicates a request to jump to the list of tasks
 */
public class JumpToTaskListRequestEvent extends BaseEvent {

    private final int targetIndex;

    public JumpToTaskListRequestEvent(int targetIndex) {
        this.targetIndex = targetIndex;
    }
    
    public int getTargetIndex() {
		return targetIndex;
	}

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### /java/seedu/manager/logic/commands/AddCommand.java
``` java
    /**
     * Convenience constructor using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(HashMap<TaskProperties, Optional<String>> properties)
            throws IllegalValueException {
        if (!properties.get(TaskProperties.DESC).isPresent()) {
            throw new IllegalValueException(MESSAGE_USAGE);
        }
        this.toAdd = new Task(properties);
        
    }
    
```
###### /java/seedu/manager/logic/commands/AliasCommand.java
``` java
/**
 * Allows user to alias commands
 *
 */
public class AliasCommand extends Command implements UndoableCommand {
	
	public static final String COMMAND_WORD = "alias";
	
	public static final String MESSAGE_SUCCESS = "Old command %1$s changed to %2$s";
	public static final String UNDO_SUCCESS = "Alias %1$s changed back to %2$s";
	public static final String MESSAGE_WRONG_NUM_ARGS = "Alias command should have exactly 2 parameters";
	public static final String MESSAGE_NO_MATCH = "I cannot recognise the command you want to alias";
	public static final String MESSAGE_ALIAS_TAKEN = "This alias is already taken by the %1$s command";
	public static final String MESSAGE_USAGE = COMMAND_WORD + ": Aliases a command to whatever you want. "
            + "Parameters: <old alias> <new alias> \n"
            + "Example: " + COMMAND_WORD
            + " add +";
	
	private final String oldCommand;
	private final String alias;
	
	public AliasCommand(String oldCommand, String alias) {
		this.oldCommand = oldCommand;
		this.alias = alias;
	}

	@Override
	public CommandResult execute() {
		return aliasCommand(oldCommand, alias, false);
	}
	
	@Override
	public CommandResult undoIt() {
		return aliasCommand(alias, oldCommand, true);
	}
	
	/**
	 * Alias a given command to a new keyword
	 * @param oldCommand The old command, which should be aliased
	 * @param alias The new alias for this command
	 * @param isBeingUndone Whether the command is being undone or not 
	 * @return CommandResult representing the outcome of the command
	 */
	private CommandResult aliasCommand(String oldCommand, String alias, boolean isBeingUndone) {
		try {
			model.setSingleCommandWord(oldCommand, alias, MESSAGE_NO_MATCH, MESSAGE_ALIAS_TAKEN);
			
			EventsCenter.getInstance().post(new CommandWordsChangedEvent());
			
			if (!isBeingUndone) {
				this.addUndo(this);
			}
			
			String messageToShow = isBeingUndone ? UNDO_SUCCESS : MESSAGE_SUCCESS; 
			return new CommandResult(String.format(messageToShow, oldCommand, alias));
		} catch (IllegalValueException e) {
			return new CommandResult(e.getMessage());
		}
	}
}
```
###### /java/seedu/manager/logic/commands/Command.java
``` java
    /**
     * Jumps to the given task
     * @param task Task to jump to
     */
    protected void jumpToTask(ReadOnlyTask task) {
    	int taskIndex = model.getIndexOfTask(task);
        assert taskIndex != -1;
        
        EventsCenter.getInstance().post(new JumpToTaskListRequestEvent(taskIndex));
    }
    
```
###### /java/seedu/manager/logic/commands/DoneCommand.java
``` java
/**
 * Marks a task identified using it's last displayed index as done.
 * 
 */
public class DoneCommand extends Command implements UndoableCommand {

    public static final String COMMAND_WORD = "done";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Marks a task identified by the index number used in the last task listing as done.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_SUCCESS = "Marked Task as Done: %1$s";
    
    public static final String UNDO_SUCCESS = "Unmarked the Task to Undone."; 

    public final int targetIndex;
    
    public Task taskToUnmark;

    public DoneCommand(int targetIndex) {
        this.targetIndex = targetIndex;
    }

    @Override
    public CommandResult execute() {
        assert model != null;

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getSortedFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToMark = lastShownList.get(targetIndex - 1);

        try {
            Task markedTask = markDonePropertyOfTask(taskToMark, true);
            model.deleteTask(taskToMark);
            model.addTask(markedTask);
            jumpToTask(markedTask);
            
            taskToUnmark = markedTask;
            this.addUndo(this);
            
            return new CommandResult(String.format(MESSAGE_SUCCESS, taskToMark));
        } catch (TaskNotFoundException pnfe) {
        	return new CommandResult("The target task cannot be missing");
        } catch (IllegalValueException e) {
			return new CommandResult(e.getMessage());
		}
    }
    
```
###### /java/seedu/manager/logic/commands/DoneCommand.java
``` java
	 * Marks the done property of a task
	 * @param taskToMark The task which should be marked
	 * @param isDone Whether it should be marked as done or not done
	 * @return The new marked task
	 * @throws IllegalValueException
	 */
	private Task markDonePropertyOfTask(ReadOnlyTask taskToMark, boolean isDone) throws IllegalValueException {
		String done = isDone ? "Yes" : "No";
		HashMap<TaskProperties, Optional<String>> propsToEdit = taskToMark.getPropertiesAsStrings();
        propsToEdit.put(TaskProperties.DONE, Optional.of(done));
        return new Task(propsToEdit);
	}
}
```
###### /java/seedu/manager/logic/commands/EditCommand.java
``` java
/**
 * Allows tasks to be edited. Uses an index to extract the task to be edited and changes its
 * properties according to the new properties given
 *
 */
public class EditCommand extends Command implements UndoableCommand {
    
    public static final String COMMAND_WORD = "edit";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Edits the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer) [DESC] [<extensions>]\n"
            + "Example: " + COMMAND_WORD + " 1 Dinner with Guinevere venue Under the Stars priority high";

    public static final String MESSAGE_SUCCESS = "Edited Task: %1$s";
    public static final String MESSAGE_DUPLICATE_PARAMS = "The new parameters are the same as before";
    public static final String UNDO_SUCCESS = "Undone the previous edit: %1$s";

    public final int targetIndex;
    
    private final HashMap<TaskProperties, Optional<String>> editedProperties;

    public EditCommand(int targetIndex, HashMap<TaskProperties, Optional<String>> editedProperties) 
            throws IllegalValueException {
        this.targetIndex = targetIndex;
        this.editedProperties = editedProperties;
    }

    public Task newTask;
    public Task oldTask;

    @Override
    public CommandResult execute() {
        assert model != null;
        
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getSortedFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToEdit = lastShownList.get(targetIndex - 1);
        
        try {
        	HashMap<TaskProperties, Optional<String>> newProperties = 
        		buildNewPropsFromOldAndEdited(taskToEdit.getPropertiesAsStrings(), editedProperties);
        	
            newTask = new Task(newProperties);
            oldTask = new Task(taskToEdit);
            
            model.addTask(newTask);
            model.deleteTask(taskToEdit);
            
            if(newTask.getTag().isPresent()) {
                model.addTag((Tag) newTask.getTag().get());
            }
            if(taskToEdit.getTag().isPresent()) {
                model.deleteTag((Tag) taskToEdit.getTag().get());
            }
            
            jumpToTask(newTask);
            this.addUndo(this);
            
            return new CommandResult(String.format(MESSAGE_SUCCESS, newTask.getAsPrettyText()));
        } catch (TaskNotFoundException e) {
            return new CommandResult("The target task cannot be missing");
        } catch (UniqueTaskList.DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_PARAMS);
        } catch (IllegalValueException e) {
			return new CommandResult(e.getMessage());
		}
    }
    
    /**
     * Builds a HashMap of new properties using old properties of task and new properties entered
     * by user
     * 
     * @param oldProperties
     * @param editedProperties
     */
    private HashMap<TaskProperties, Optional<String>> buildNewPropsFromOldAndEdited(
            HashMap<TaskProperties, Optional<String>> oldProperties, 
            HashMap<TaskProperties, Optional<String>> editedProperties
            ) {
        HashMap<TaskProperties, Optional<String>> newProperties = new HashMap<>();
        
        for (TaskProperties prop : TaskProperties.values()) {
            if (editedProperties.get(prop).isPresent()) {
                newProperties.put(prop, editedProperties.get(prop));
            } else {
                newProperties.put(prop, oldProperties.get(prop));
            }
        }
        
        return newProperties;
    }
    
```
###### /java/seedu/manager/logic/commands/FindCommand.java
``` java
    /**
     * If tag is present in the search properties, then raises an event requesting jump to that tag 
     * @param properties
     */
    private void jumpToTagIfPresent(HashMap<TaskProperties, Optional<TaskProperty>> properties) {
    	if (properties.get(TaskProperties.TAG).isPresent()) {
			int targetIndex = model.getIndexOfTag((Tag) properties.get(TaskProperties.TAG).get());
			if (targetIndex != -1) {
				EventsCenter.getInstance().post(new JumpToTagListRequestEvent(targetIndex));
			}
		}
    }
}
```
###### /java/seedu/manager/logic/commands/HelpCommand.java
``` java
/**
 * Format full help instructions for every command for display.
 * 
 */
public class HelpCommand extends Command {

    public static final String COMMAND_WORD = "help";
    public static final String MESSAGE_WRONG_NUM_ARGS = "Help command cannot have more than 1 parameter";
    public static final String MESSAGE_WRONG_HELP_COMMAND = "Cannot recognise given command, so no help shown";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Shows program usage instructions. "
    		+ "If a command is specified, then instructions for that command will be shown. \n"
    		+ "Parameters: [<command>] \n"
            + "Example: " + COMMAND_WORD
            + " add";

    public static final String SHOWING_HELP_MESSAGE = "Opened help window.";
    
    public static final String MESSAGE_AT_USAGE = "at: Let's you specify that the task takes place at a certain time. "
            + "Parameters: <time> \n"
            + "Example: at tomorrow 5pm";
    public static final String MESSAGE_BY_USAGE = "by: Let's you specify a deadline for the task. "
            + "Parameters: <time> \n"
            + "Example: by tomorrow 5pm";
    public static final String MESSAGE_EVENT_USAGE = "from-to: Let's you specify start and end times for the task. "
            + "Parameters: <start time> to <end time>\n"
            + "Example: from 7pm to 9pm";
    public static final String MESSAGE_PRIORITY_USAGE = "priority: Let's you specify a priority for the task. "
            + "Parameters: <low/med/high>\n"
            + "Example: priority low";
    public static final String MESSAGE_VENUE_USAGE = "venue: Let's you specify the task's venue. "
            + "Parameters: <Task Venue> \n"
            + "Example: venue Avalon";
    public static final String MESSAGE_TAG_USAGE = "tag: Let's you specify the task's tag. "
            + "Parameters: <Tag> \n"
            + "Example: tag Legend";
    
    private final Optional<String> commandToGetHelpFor;
    private static final HashMap<Commands, String> usageMessages = new HashMap<>();
    
    static {
    	buildUsageMessageHashmap();
    }

    public HelpCommand(Optional<String> commandToGetHelpFor) {
    	this.commandToGetHelpFor = commandToGetHelpFor;
    }

    @Override
    public CommandResult execute() {
        if (commandToGetHelpFor.isPresent()) {
			return getHelpForMatchingCommand(commandToGetHelpFor.get());
		} else {
			EventsCenter.getInstance().post(new ShowHelpRequestEvent());
			return new CommandResult(SHOWING_HELP_MESSAGE);
		}
    }
    
    /**
     * Creates a hashmap of usage messages for all commands and extensions
     */
    private static void buildUsageMessageHashmap() {
    	usageMessages.put(Commands.ADD, AddCommand.MESSAGE_USAGE);
		usageMessages.put(Commands.ALIAS, AliasCommand.MESSAGE_USAGE);
		usageMessages.put(Commands.CLEAR, ClearCommand.MESSAGE_USAGE);
		usageMessages.put(Commands.DELETE, DeleteCommand.MESSAGE_USAGE);
		usageMessages.put(Commands.DONE, DoneCommand.MESSAGE_USAGE);
		usageMessages.put(Commands.EDIT, EditCommand.MESSAGE_USAGE);
		usageMessages.put(Commands.EXIT, ExitCommand.MESSAGE_USAGE);
		usageMessages.put(Commands.FIND, FindCommand.MESSAGE_USAGE);
		usageMessages.put(Commands.HELP, HelpCommand.MESSAGE_USAGE);
		usageMessages.put(Commands.LIST, ListCommand.MESSAGE_USAGE);
		usageMessages.put(Commands.SORT, SortCommand.MESSAGE_USAGE);
		usageMessages.put(Commands.STORAGE, StorageCommand.MESSAGE_USAGE);
		usageMessages.put(Commands.UNSORT, UnSortCommand.MESSAGE_USAGE);
		usageMessages.put(Commands.UNDO, UndoCommand.MESSAGE_USAGE);
		
		usageMessages.put(Commands.AT, MESSAGE_AT_USAGE);
		usageMessages.put(Commands.BY, MESSAGE_BY_USAGE);
		usageMessages.put(Commands.EVENT, MESSAGE_EVENT_USAGE);
		usageMessages.put(Commands.PRIORITY, MESSAGE_PRIORITY_USAGE);
		usageMessages.put(Commands.TAG, MESSAGE_TAG_USAGE);
		usageMessages.put(Commands.VENUE, MESSAGE_VENUE_USAGE);
    }
    
    /**
     * Gets the help message for a certain command
     * @param commandToGetHelpFor The command to get help for
     * @return CommandResult representing the help for the given command
     */
    private CommandResult getHelpForMatchingCommand(String commandToGetHelpFor) {
    	try {
			Commands matchedCommand = getMatchedKeyword(commandToGetHelpFor);
			String helpForCommand = constructUsageMessageForCommand(matchedCommand);
			
			String aliasForCommand = "Alias: " + model.getAliasForCommand(matchedCommand);
			
			return new CommandResult(helpForCommand + "\n" + aliasForCommand);
			
		} catch (IllegalValueException e) {
			indicateAttemptToExecuteIncorrectCommand();
			return new CommandResult(e.getMessage());
		}
    }
    
    /**
     * Gets the command keyword matching the user input
     * @param userInputCommand Command that user gave as a String
     * @return Command that matches the user input
     * @throws IllegalValueException If no matching command
     */
    private Commands getMatchedKeyword(String userInputCommand) throws IllegalValueException {
    	for (Commands command : Commands.values()) {
			if (command.toString().equals(userInputCommand)) {
				return command;
			}
		}
    	
    	throw new IllegalValueException(MESSAGE_WRONG_HELP_COMMAND);
    }
    
    /**
     * Constructs the usage message for a command
     * @param command The command for which the usage message will be made
     * @return The usage message for input command
     */
    private String constructUsageMessageForCommand(Commands command) {
    	if (usageMessages.containsKey(command)) {
			return usageMessages.get(command);
		} else {
			return MESSAGE_WRONG_HELP_COMMAND;
		}
    }
}
```
###### /java/seedu/manager/logic/commands/SortCommand.java
``` java
/**
 * Allows user to sort the displayed tasks by priority
 *
 */	
public class SortCommand extends Command implements UndoableCommand{
	public static final String COMMAND_WORD = "sort";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Sorts the displayed tasks by priority, from highest to lowest. Tasks with no priority are shown last.\n"
            + "Example: " + COMMAND_WORD;

    public static final String MESSAGE_SUCCESS = "Sorted task list.";
    public static final String UNDO_SUCCESS = "Unsorted task list.";
    
    public SortCommand() {}

	@Override
	public CommandResult execute() {
		model.sortSortedFilteredTaskListByProperty(TaskProperties.PRIORITY);
		this.addUndo(this);
		return new CommandResult(MESSAGE_SUCCESS);
	}

	@Override
	public CommandResult undoIt() {
		model.unSortSortedFilteredTaskList();
	    return new CommandResult(UNDO_SUCCESS);
	}
}
```
###### /java/seedu/manager/logic/commands/StorageCommand.java
``` java
/**
 * Allows user to change the storage location
 *
 */
public class StorageCommand extends Command {
	
	public static final String COMMAND_WORD = "storage";
	
    public static final String MESSAGE_SUCCESS = "Changed storage location to %1$s";
    public static final String MESSAGE_WRONG_EXTENSION =  "File must have a .xml extension";
    public static final String MESSAGE_CANNOT_CREATE = "Unable to create file, please check path provided";
    public static final String MESSAGE_ALREADY_EXISTS_SUCCESS = MESSAGE_SUCCESS
    			+ "\nWarning - file already exists, overwriting old data";
    public static final String MESSAGE_ALREADY_EXISTS_NO_OVERWRITE = "File already exists, and I don't have permission to overwrite it";
    public static final String MESSAGE_NO_PERMISSION = "I don't have permission to access this location";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Changes the storage location. "
            + "Parameters: <path/to/file/fileName.xml> \n"
            + "Example: " + COMMAND_WORD
            + " data/myFile.xml";
    
    private String filePath;
    
    public StorageCommand(String filePath) {
		this.filePath = filePath;
	}

	@Override
	public CommandResult execute() {
		if (!hasXmlExtension(filePath)) {
			return new CommandResult(MESSAGE_WRONG_EXTENSION);
		}
		
		String feedbackToUser;
		if (doesfileAlreadyExist(filePath)) {
			if (canOverWriteExisting(filePath)) {
				feedbackToUser = String.format(MESSAGE_ALREADY_EXISTS_SUCCESS, filePath);
			} else {
				return new CommandResult(MESSAGE_ALREADY_EXISTS_NO_OVERWRITE);
			}
		} else {
			if (canWriteToFile(filePath)) {
				feedbackToUser = String.format(MESSAGE_SUCCESS, filePath);
			} else {
				return new CommandResult(MESSAGE_NO_PERMISSION);
			}
		}
		
		EventsCenter.getInstance().post(new StorageLocationChangedEvent(filePath));
		EventsCenter.getInstance().post(new TaskManagerChangedEvent(model.getTaskManager())); // save to new location
		return new CommandResult(feedbackToUser);
	}
	
	private boolean hasXmlExtension(String filePath) {
		return filePath.endsWith(".xml") && !filePath.equals("");
	}
	
	private boolean doesfileAlreadyExist(String filePath) {
		File file = new File(filePath);
		return file.exists();
	}
	
	private boolean canOverWriteExisting(String filePath) {
		try {
			File file = new File(filePath).getParentFile();
			return file.canWrite();
		} catch (Exception e) {
			return false;
		}
	}
	
	private boolean canWriteToFile(String filePath) {
		try {
			File file = new File(filePath).getParentFile();
			return file.canWrite();
		} catch (Exception e) {
			return false;
		}
	}
}
```
###### /java/seedu/manager/logic/commands/UnSortCommand.java
``` java
/**
 * Allows user to unsort the displayed tasks, placing completed tasks at the bottom
 *
 */	
public class UnSortCommand extends Command implements UndoableCommand {
	public static final String COMMAND_WORD = "unsort";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Unsorts the task list, moving done tasks to the bottom.\n"
            + "Example: " + COMMAND_WORD;

    public static final String MESSAGE_SUCCESS = "Unsorted task list.";
    public static final String UNDO_SUCCESS = "Sorted task list.";
    
    public UnSortCommand() {}

	@Override
	public CommandResult execute() {
		model.unSortSortedFilteredTaskList();;
		this.addUndo(this);
		return new CommandResult(MESSAGE_SUCCESS);
	}

	@Override
	public CommandResult undoIt() {
		model.sortSortedFilteredTaskListByProperty(TaskProperties.PRIORITY);
	    return new CommandResult(UNDO_SUCCESS);
	}
}
```
###### /java/seedu/manager/logic/LogicManager.java
``` java
    public LogicManager(Model model, Storage storage) {
        this.model = model;
        this.parser = new Parser(model.getCommandWords(), model.getExtensionWords());
    }
    
```
###### /java/seedu/manager/logic/LogicManager.java
``` java
    @Subscribe
    /**
     * Updates parser with the new command words when these are changed
     * @param event
     */
    public void handleCommandWordsChangedEvent(CommandWordsChangedEvent event) {
    	parser.compileRegexes();
    }
}
```
###### /java/seedu/manager/logic/parser/ExtensionParser.java
``` java
/**
 * Used to parse extensions in the user input
 *
 */
public class ExtensionParser {
    public static final String EXTENSION_FROM_TO_INVALID_FORMAT = "From-to times should be in the format from <startTime> to <endTime>";
    public static final String EXTENSION_DUPLICATES = "Extensions should only contain one %1$s";
    public static final String START_AFTER_END = "Start time should be before end time.";
    
    private static final String ESCAPING_CHARACTER = "'"; 
    private final String EXTENSION_INVALID_FORMAT = "Extensions should have the form <extension> <arguments>";
    private String EXTENSION_REGEX_OPTIONS;
    private Pattern EXTENSIONS_DESC_FORMAT;
    private Pattern EXTENSIONS_ARGS_FORMAT;
    private final Pattern EXTENSION_ARGS_FORMAT = 
            Pattern.compile("(?<commandWord>\\S+)(?<arguments>.*)");
    private final Pattern EVENT_ARGS_FORMAT = 
            Pattern.compile("(?<startTime>.+?)\\sto\\s(?<endTime>.+)");
    
    private HashMap<Commands, String> extensionWords = null;
    private ArrayList<Tag> tagList;
    
    public ExtensionParser(HashMap<Commands, String> extensionWordsIn) {
        tagList = new ArrayList<Tag>();
        extensionWords = extensionWordsIn;
        compileRegexes();
    }
    
    public ArrayList<Tag> getTagList() {
        return tagList;
    }
    
    public void compileRegexes() {
    	EXTENSION_REGEX_OPTIONS = String.join("|", extensionWords.values());
        EXTENSIONS_DESC_FORMAT = 
                Pattern.compile("(^.*?(?=(?:(?:(?:\\s|^)(?:"
                        + EXTENSION_REGEX_OPTIONS
                        + ")\\s)|$)))");
        EXTENSIONS_ARGS_FORMAT =
                Pattern.compile("((?:^|\\s)(?:"
                        + EXTENSION_REGEX_OPTIONS
                        + ")\\s.+?(?=(?:(?:\\s(?:"
                        + EXTENSION_REGEX_OPTIONS
                        + ")\\s)|$)))");
    }
    
    /**
     * Build task from extensions
     * @param extensionsStr String containing the extensions to be parsed
     * @return Hashmap of properties representing the new task
     * @throws IllegalValueException
     */
    public HashMap<TaskProperties, Optional<String>> getTaskProperties(String extensionsStr) 
    		throws IllegalValueException {
        HashMap<TaskProperties, Optional<String>> properties = new HashMap<>();
        extensionsStr = extensionsStr.trim();
        
        for (TaskProperties property : TaskProperties.values()) {
            properties.put(property, Optional.empty());
        }
        
        parseDesc(extensionsStr, properties);
        
        Matcher extMatcher = EXTENSIONS_ARGS_FORMAT.matcher(extensionsStr);
        while (extMatcher.find()) {
            parseSingleExtension(extMatcher.group().trim(), properties);
        }
        
        return properties;
    }
    
    /**
     * Parses the task description into the properties
     * @param extensionsStr Full string containing the extensions
     * @param properties The Hashmap of properties to which the description will be added
     */
    private void parseDesc(String extensionsStr, HashMap<TaskProperties, Optional<String>> properties) {
    	Matcher descMatcher = EXTENSIONS_DESC_FORMAT.matcher(extensionsStr);
        if (descMatcher.find()) {
            String desc = descMatcher.group().trim();
            desc = removeEscapingChars(desc);
            properties.put(TaskProperties.DESC, 
                    desc.equals("") ? Optional.empty() : Optional.of(desc));
        }
    }
    
    /**
     * Parses a single extension given a string containing extension word and arguments
     * @param extension User input with only one extension and arguments
     * @param properties The Hashmap of properties to which the new extension will be added
     * @throws IllegalValueException
     */
    private void parseSingleExtension(String extension, HashMap<TaskProperties, Optional<String>> properties) 
            throws IllegalValueException{
    	
        Matcher matcher = EXTENSION_ARGS_FORMAT.matcher(extension);
        
        if (matcher.matches()) {
            String extensionCommand = matcher.group("commandWord").trim();
            String arguments = matcher.group("arguments").trim();
            arguments = removeEscapingChars(arguments);
            
            Commands matchedCommand = getMatchedCommand(extensionCommand);
            
            switch (matchedCommand) {
            case VENUE:
                throwExceptionIfDuplicate(properties, TaskProperties.VENUE, Commands.VENUE);
                addToProperties(properties, TaskProperties.VENUE, arguments);
                break;
            case BY:
                throwExceptionIfDuplicate(properties, TaskProperties.ENDTIME, Commands.BY);
                addToProperties(properties, TaskProperties.ENDTIME, arguments);
                break;
            case AT:
                throwExceptionIfDuplicate(properties, TaskProperties.STARTTIME, Commands.AT);
                addToProperties(properties, TaskProperties.STARTTIME, arguments);
                break;
            case EVENT:
                throwExceptionIfDuplicate(properties, TaskProperties.STARTTIME, Commands.EVENT);
                throwExceptionIfDuplicate(properties, TaskProperties.ENDTIME, Commands.EVENT);
                addEvent(properties, arguments);
                break;
            case PRIORITY:
                throwExceptionIfDuplicate(properties, TaskProperties.PRIORITY, Commands.PRIORITY);
                addToProperties(properties, TaskProperties.PRIORITY, arguments);
                break;
            case TAG:
                throwExceptionIfDuplicate(properties, TaskProperties.TAG, Commands.TAG);
                addToTagList(arguments);
                addToProperties(properties, TaskProperties.TAG, arguments);
                break;
            default:
                throw new IllegalValueException(EXTENSION_INVALID_FORMAT);
            }
        } else {
            throw new IllegalValueException(EXTENSION_INVALID_FORMAT);
        }
    }
    
    /**
     * Get the extension command which matches the input command
     * @param extensionCommand
     */
	private Commands getMatchedCommand(String extensionCommand) throws IllegalValueException {
		for (Commands command : Commands.values()) {
		    if (extensionWords.containsKey(command) && extensionWords.get(command).equals(extensionCommand)) {
		        return command;
		    }
		}
		
		throw new IllegalValueException(EXTENSION_INVALID_FORMAT);
	}
	
	/**
	 * Removes the escaping characters from extension arguments
	 * @param args Arguments to remove escape characters from
	 * @return Arguments without the escaping characters
	 */
	private String removeEscapingChars(String args) {
		for (String extensionWord : extensionWords.values()) {
			args = args.replaceAll(ESCAPING_CHARACTER + extensionWord + ESCAPING_CHARACTER, extensionWord);
		}
		return args;
	}
    
	/**
	 * Throws an exception if duplicate properties are specified
	 * 
	 * @param properties Properties to look in.
	 * @param taskProperty Property to check.
	 * @param extensionCmd Command that caused duplication.
	 * @throws IllegalValueException
	 */
    private void throwExceptionIfDuplicate(HashMap<TaskProperties, Optional<String>> properties,
            							   TaskProperties taskProperty,
            							   Commands extensionCmd) throws IllegalValueException {
        if (properties.get(taskProperty).isPresent()) {
            throw new IllegalValueException(String.format(EXTENSION_DUPLICATES, extensionWords.get(extensionCmd)));
        }
    }

    private void addEvent(HashMap<TaskProperties, Optional<String>> properties, String arguments)
    		     throws IllegalValueException {
        Matcher matcher = EVENT_ARGS_FORMAT.matcher(arguments);
        
        if (!matcher.matches()) {
            throw new IllegalValueException(EXTENSION_FROM_TO_INVALID_FORMAT);
        }
        
        String startTime = matcher.group("startTime").trim();
        String endTime = matcher.group("endTime").trim();
        
        addToProperties(properties, TaskProperties.STARTTIME, startTime);
        addToProperties(properties, TaskProperties.ENDTIME, endTime);
        
        throwExceptionIfTimeInvalid(startTime, endTime);
    }
    
    /**
```
###### /java/seedu/manager/logic/parser/ExtensionParser.java
``` java
    /**
     * Adds a property to the properties HashMap
     * 
     * @param properties HashMap to put the new property into.
     * @param taskProperty Property to put.
     * @param arguments Value of the property.
     */
    private void addToProperties(HashMap<TaskProperties, Optional<String>> properties, 
            					 TaskProperties taskProperty, String arguments) {
        properties.put(taskProperty, arguments.equals("") ? Optional.empty() : Optional.of(arguments));
    }
    
```
###### /java/seedu/manager/logic/parser/Parser.java
``` java
/**
 * Parses user input.
 */
public class Parser {
    /**
     * Used for initial separation of command word and args.
     */
    private static final Pattern BASIC_COMMAND_FORMAT = Pattern.compile("(?<commandWord>\\S+)(?<arguments>.*)");

    private static final Pattern PERSON_INDEX_ARGS_FORMAT = Pattern.compile("(?<targetIndex>.+)");
    
    private static final Pattern EDIT_KEYWORDS_FORMAT =
            Pattern.compile("(?<targetIndex>\\d+)\\s(?<arguments>.+)");
    
    private static final Pattern FIND_KEYWORDS_FORMAT =
            Pattern.compile("(?<arguments>.+)");
    
    private final ExtensionParser extParser;
    
    private HashMap<Commands, String> commandWords = null;

    /**
     * Constructs a parser given command words and extension words
     * @param commandWords
     * @param extensionWords
     */
    public Parser(HashMap<Commands, String> commandWords, HashMap<Commands, String> extensionWords) {
    	this.commandWords = commandWords;
    	extParser = new ExtensionParser(extensionWords);
    }
    
    /**
     * Compiles the regexes used in the parser
     */
    public void compileRegexes() {
    	extParser.compileRegexes();
    }
    
    /**
     * Parses user input into command for execution.
     *
     * @param userInput full user input string
     * @return the command based on the user input 
     */
    public Command parseCommand(String userInput) {
    	assert commandWords != null;
    	
        final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(userInput.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }

        final String commandWord = matcher.group("commandWord").trim();
        final String arguments = matcher.group("arguments").trim();
        
        Commands matchedCommand;
        
        try {
			matchedCommand = getMatchedCommand(commandWord);
		} catch (IllegalValueException e) {
			return new IncorrectCommand(e.getMessage());
		}
        
        switch (matchedCommand) {

        case ADD:
            return prepareAdd(arguments);

        case DELETE:
            return prepareDelete(arguments);
            
        case EDIT:
            return prepareEdit(arguments);

        case CLEAR:
            return new ClearCommand();

        case FIND:
            return prepareFind(arguments);
        
        case DONE:
            return prepareDone(arguments);

        case LIST:
            return new ListCommand();

        case EXIT:
            return new ExitCommand();

        case HELP:
            return prepareHelp(arguments);
        
        case STORAGE:
            return new StorageCommand(arguments);
        
        case SORT:
        	return new SortCommand();
        
        case UNSORT:
        	return new UnSortCommand();
        
        case UNDO:
        	return new UndoCommand();

        case ALIAS:
        	return prepareAlias(arguments);

        default:
            return new IncorrectCommand(MESSAGE_UNKNOWN_COMMAND);
        }
    }
    
    /**
     * Get the command which matches with the command word entered by the user
     * @param commandWord
     * @throws IllegalValueException
     */
    private Commands getMatchedCommand(String commandWord) throws IllegalValueException {
    	for (Commands command : Commands.values()) {
			if (commandWords.containsKey(command) && commandWords.get(command).equals(commandWord)) {
				return command;
			}
		}
    	
    	throw new IllegalValueException(MESSAGE_UNKNOWN_COMMAND);
    }

	/**
     * Parses arguments in the context of the add task command.
     * @param args full command args string
     * @return the prepared command 
     */
    private Command prepareAdd(String args) {        
        try {
            return new AddCommand(
                    extParser.getTaskProperties(args)
            );
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }
    
```
###### /java/seedu/manager/logic/parser/Parser.java
``` java
    /**
     * Parses arguments in the context of the done task command
     * @param args full commmand args string
     * @return the prepared command
     */
    private Command prepareDone(String args) {
    	Optional<Integer> index = parseIndex(args);
        if(!index.isPresent()){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, DoneCommand.MESSAGE_USAGE));
        }

        return new DoneCommand(index.get());
	}
    
```
###### /java/seedu/manager/logic/parser/Parser.java
``` java
    /**
     * Parses arguments in the context of the alias command
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareAlias(String args) {
    	String[] splitArgs = args.trim().split(" ");
    	if (splitArgs.length != 2) {
			return new IncorrectCommand(AliasCommand.MESSAGE_WRONG_NUM_ARGS);
		}
    	
    	return new AliasCommand(splitArgs[0], splitArgs[1]);
    }
    
    /**
     * Parses arguments in the context of the help command
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareHelp(String args) {
    	String[] splitArgs = args.trim().split(" ");
    	System.out.println(splitArgs.length);
    	System.out.println(splitArgs);
    	if (splitArgs.length > 1) {
			return new IncorrectCommand(HelpCommand.MESSAGE_WRONG_NUM_ARGS);
		} else if (splitArgs.length == 1 && !splitArgs[0].equals("")) {
			return new HelpCommand(Optional.of(splitArgs[0]));
		} else {
			return new HelpCommand(Optional.empty());
		}
    }
}
```
###### /java/seedu/manager/model/Model.java
``` java
    /** Returns the Command words */
    HashMap<Commands, String> getCommandWords();
    
    /** Returns the Extension words */
    HashMap<Commands, String> getExtensionWords();
    
```
###### /java/seedu/manager/model/Model.java
``` java
    /**
     * Gets the alias for a certain command from the user preferences
     * @param command Command for which alias will be returned 
     * @return Alias of the command
     */
    public String getAliasForCommand(Commands command);
    
    /**
     * Changes a command to a given alias in the user preferences
	 * @param commandToChange The command which should be aliased
	 * @param alias The alias which will be assigned to the command
	 * @param messageNoMatch Message used in error which will be thrown if there is no matching command
	 * @param messageAliasAlreadyTaken Message used in error which will be thrown if alias is already taken
	 * @throws IllegalValueException
     */
    public void setSingleCommandWord(String commandToChange, String alias,
    		String messageNoMatch, String messageAliasAlreadyTaken) throws IllegalValueException;
    
```
###### /java/seedu/manager/model/Model.java
``` java
    /**
     * Get the index of a specified tag in the list currently being displayed
     * @param tag Tag whose index will be returned
     * @return index of the tag
     */
    int getIndexOfTag(Tag tag);
    
```
###### /java/seedu/manager/model/Model.java
``` java
    /** Sorts the sorted and filtered task list by a certain property */
    void sortSortedFilteredTaskListByProperty(TaskProperties property);
    
    /** Unsorts the sorted and filtered task list */
    void unSortSortedFilteredTaskList();
    
    /** 
     * Get the index of a specified tag in the list currently being displayed
     * @param task Task whose index will be returned
     * @return index of the task 
     */
    int getIndexOfTask(ReadOnlyTask task);
}
```
###### /java/seedu/manager/model/ModelManager.java
``` java
     * Retrieves command words from the user preferences
     */
    public HashMap<Commands, String> getCommandWords() {
    	return userPrefs.commandWords;
    }
    
    @Override
    /**
     * Retrieves extension words from the user preferences
     */
    public HashMap<Commands, String> getExtensionWords() {
    	return userPrefs.extensionWords;
    }
    
```
###### /java/seedu/manager/model/ModelManager.java
``` java
    @Override
    public String getAliasForCommand(Commands command) {
    	return userPrefs.getAliasForCommand(command);
    }
    
	@Override
	public void setSingleCommandWord(String commandToChange, String alias,
			String messageNoMatch, String messageAliasAlreadyTaken) throws IllegalValueException {
		userPrefs.setSingleCommandWord(commandToChange, alias, messageNoMatch, messageAliasAlreadyTaken);
	}
	
	//=========== Sorted and Filtered Tag List Accessors ===============================================================
	
	@Override
    public int getIndexOfTag(Tag tag) {
    	return sortedTags.indexOf(tag);
    }
    
    //=========== Sorted and Filtered Task List Accessors ===============================================================

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getSortedFilteredTaskList() {
        return new UnmodifiableObservableList<>(sortedTasks);
    }
    
```
###### /java/seedu/manager/model/ModelManager.java
``` java
    @Override
    public void updateSortedFilteredTaskListToShowAll() {
        updateFilteredTaskListToShowAll();
    }
    
    @Override
    public void sortSortedFilteredTaskListByProperty(TaskProperties property) {
    	sortedTasks.setComparator((Task t1, Task t2) -> t1.compareProperty(t2, property));
    }
    
    @Override
    public void unSortSortedFilteredTaskList() {
    	sortSortedFilteredTaskListByProperty(TaskProperties.DONE);
    }
    
    @Override
    public int getIndexOfTask(ReadOnlyTask task) {
    	return sortedTasks.indexOf(task);
    }

```
###### /java/seedu/manager/model/task/Desc.java
``` java
    /**
     * Validates given desc.
     * @throws IllegalValueException if given desc string is invalid.
     */
    public Desc(String desc) throws IllegalValueException {
        super(desc, DESC_VALIDATION_REGEX, MESSAGE_DESC_CONSTRAINTS);
        value = desc;
    }

```
###### /java/seedu/manager/model/task/Desc.java
``` java
    @Override
    public String getPrettyValue() {
    	if (value.length() > PRETTY_MAX_LENGTH) {
    		return value.substring(0, PRETTY_MAX_LENGTH - 3) + "...";
    	} else {
			return value;
		}
    }
    
    /**
```
###### /java/seedu/manager/model/task/Done.java
``` java
    /**
     * Validates given done indicator.
     * @throws IllegalValueException if given done indicator address string is invalid.
     */
    public Done(String done) throws IllegalValueException {
        super(done, DONE_VALIDATION_REGEX, MESSAGE_DONE_CONSTRAINTS);
        value = done.equals("Yes") ? true : false;
    }

    @Override
    public String toString() {
        return value ? "Yes" : "No";
    }
    
    @Override
    public String getPrettyValue() {
        return value ? "\u2713" : "";
    }
    
    /**
```
###### /java/seedu/manager/model/task/Done.java
``` java
    @Override
    public int compareTo(TaskProperty other) {
    	assert other instanceof Done;
    	
    	if (this.isTrue() && !((Done) other).isTrue()) {
			return 1;
		} else if (!this.isTrue() && ((Done) other).isTrue()) {
			return -1;
		} else {
			return 0;
		}
    }
}
```
###### /java/seedu/manager/model/task/Priority.java
``` java
    private static enum VALUES {
    	LOW("low"), MED("med"), HIGH("high");
    	
    	private String value;
        
        private VALUES(String value) {
            this.value = value;
        }
    }
    private VALUES value = null;
    
    /**
     * Validates given priority.
     *
     * @throws IllegalValueException if given priority string is invalid.
     */
    public Priority(String priority) throws IllegalValueException {
        super(priority, PRIORITY_VALIDATION_REGEX, MESSAGE_PRIORITY_CONSTRAINTS);
        for (VALUES val : VALUES.values()) {
			if (priority.equals(val.value)) {
				value = val;
			}
		}
        if (value == null) {
        	throw new IllegalValueException(MESSAGE_PRIORITY_CONSTRAINTS);
		}
    }

    @Override
    public String toString() {
        return value.value;
    }
    
    /**
```
###### /java/seedu/manager/model/task/Priority.java
``` java
    @Override
    public int compareTo(TaskProperty other) {
    	assert other instanceof Priority;
    	
    	if (this.value.equals(((Priority) other).value)) {
			return 0;
		} else if (this.value.equals(VALUES.LOW) || ((Priority) other).value.equals(VALUES.HIGH)) {
			return 1;
		} else {
			return -1;
		}
    }
}
```
###### /java/seedu/manager/model/task/ReadOnlyTask.java
``` java
    /**
     * Returns true if both have the same state. (interfaces cannot override .equals)
     */
    default boolean isSameStateAs(ReadOnlyTask other) {
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                && other.getDesc().equals(this.getDesc()) // state checks here onwards
                && other.getVenue().equals(this.getVenue())
                && other.getPriority().equals(this.getPriority())
                && other.getStartTime().equals(this.getStartTime())
                && other.getEndTime().equals(this.getEndTime())
        		&& other.getDone().equals(this.getDone()))
                && other.getTag().equals(this.getTag());
    }

    /**
```
###### /java/seedu/manager/model/task/ReadOnlyTask.java
``` java
    /**
     * Formats the task as pretty text, meant to be displayed on the UI and in messages
     */
    default String getAsPrettyText() {
    	final StringBuilder builder = new StringBuilder();
        builder.append(getDesc().get().toPrettyString());

        if (getVenue().isPresent()) {
            builder.append(" Venue: ").append(getVenue().get().toPrettyString());
        }
        if (getPriority().isPresent()) {
            builder.append(" Priority: ").append(getPriority().get().toPrettyString());
        }
        if (getStartTime().isPresent()) {
            builder.append(" Start Time: ").append(getStartTime().get().toPrettyString());
        }
        if (getEndTime().isPresent()) {
            builder.append(" End Time: ").append(getEndTime().get().toPrettyString());
        }
        if (getTag().isPresent()) {
            builder.append(" Tag: ").append(getTag().get().toPrettyString());
        }
        return builder.toString();
    }
    
    /**
     * Compares two tasks using a certain property (for sorting)
     * @param other Other task
     * @param property Property to be compared on
     * @return -1 if this is smaller, 0 if equal, 1 is this is larger
     */
    public int compareProperty(ReadOnlyTask other, TaskProperties property);
    
    // @author A0139621H
    public boolean matches(HashMap<TaskProperties, Optional<TaskProperty>> other);
}
```
###### /java/seedu/manager/model/task/Task.java
``` java
    /**
     * Build task from properties represented as Strings
     * @param properties Hashmap with properties represented as strings
     * @throws IllegalValueException
     */
    public Task(HashMap<TaskProperties, Optional<String>> properties) throws IllegalValueException {
        assert properties.get(TaskProperties.DESC).isPresent();
        assert !properties.get(TaskProperties.DESC).get().equals("");
        
        for (Entry<TaskProperties, Optional<String>> prop : properties.entrySet()) {
        	Optional<TaskProperty> taskProperty = buildProperty(prop.getKey(), prop.getValue());
            this.properties.put(prop.getKey(), taskProperty);
        }
    }

	/**
	 * Task Constructor from individual strings. Empty strings indicate empty properties. 
	 * Every field must be present and not null. Desc cannot be empty
	 * @param desc Task's description
	 * @param venue Task's venue
	 * @param priority Task's priority
	 * @param startTime Task's start time
	 * @param endTime Task's end time
	 * @param done Whether task is done
	 * @param tag Task's tag
	 * @throws IllegalValueException
	 */
    public Task(String desc, String venue, String priority, String startTime, String endTime, String done, String tag) throws IllegalValueException {
       assert !CollectionUtil.isAnyNull(desc, venue, priority, startTime, endTime, done, tag);
       assert !desc.equals("");

       properties.put(TaskProperties.DESC, Optional.of(new Desc(desc)));
       properties.put(TaskProperties.VENUE, venue.equals("") ? Optional.empty() : Optional.of(new Venue(venue)));
       properties.put(TaskProperties.PRIORITY, priority.equals("") ? Optional.empty() : Optional.of(new Priority(priority)));
       properties.put(TaskProperties.STARTTIME, startTime.equals("") ? Optional.empty() : Optional.of(new StartTime(startTime)));
       properties.put(TaskProperties.ENDTIME, endTime.equals("") ? Optional.empty() : Optional.of(new EndTime(endTime)));
       properties.put(TaskProperties.DONE, done.equals("") ? Optional.of(new Done("No")) : Optional.of(new Done(done)));
       properties.put(TaskProperties.TAG, tag.equals("") ? Optional.empty() : Optional.of(new Tag(tag)));
    }

    /**
     * Copy constructor
     * @param source Task which will be copied
     */
    public Task(ReadOnlyTask source) {
        HashMap<TaskProperties, Optional<TaskProperty>> properties = source.getProperties();
        assert properties.containsKey(TaskProperties.DESC) && properties.get(TaskProperties.DESC).isPresent();
        assert properties.containsKey(TaskProperties.DONE) && properties.get(TaskProperties.DONE).isPresent();
        
        for (Entry<TaskProperties, Optional<TaskProperty>> prop : properties.entrySet()) {
            this.properties.put(prop.getKey(), prop.getValue());
        }
    }

    /**
     * Get properties of task as TaskProperty objects
     * @return clone of Task's properties
     */
    @Override
    public HashMap<TaskProperties, Optional<TaskProperty>> getProperties() {
        HashMap<TaskProperties, Optional<TaskProperty>> clone = new HashMap<>();
        for (Entry<TaskProperties, Optional<TaskProperty>> prop : properties.entrySet()) {
            clone.put(prop.getKey(), prop.getValue());
        }
        return clone;
    }
    
    /**
     * Get properties of task as Strings
     */
    @Override
    public HashMap<TaskProperties, Optional<String>> getPropertiesAsStrings() {
        HashMap<TaskProperties, Optional<String>> clone = new HashMap<>();
        for (Entry<TaskProperties, Optional<TaskProperty>> prop : properties.entrySet()) {
            clone.put(prop.getKey(), prop.getValue().map(TaskProperty::getValue));
        }
        return clone;
    }
    
    /**
     * Builds a TaskProperty object using a value from the TaskProperties enum and a value
     * @param property that should be built
     * @param Optional which may have the value of the property, or be empty
     * @return An optional containing a property if the input had one, else empty
     */
    private Optional<TaskProperty> buildProperty(TaskProperties property, Optional<String> value) throws IllegalValueException {
    	if (!value.isPresent()) {
    		if (property == TaskProperties.DONE) {
				return Optional.of(new Done("No"));
			}
    		else {
    			return Optional.empty();
			}
    	}
    	String stringValue = value.get();
    	
		switch (property) {
		case DESC:
			return Optional.of(new Desc(stringValue));
		case VENUE:
			return Optional.of(new Venue(stringValue));
		case STARTTIME:
			return Optional.of(new StartTime(stringValue));
		case ENDTIME:
			return Optional.of(new EndTime(stringValue));
		case PRIORITY:
			return Optional.of(new Priority(stringValue));
		case DONE:
			return Optional.of(new Done(stringValue));
		case TAG:
		    return Optional.of(new Tag(stringValue));
		default:
			throw new IllegalValueException("Property not found");
		}
	}

    @Override
    public Optional<TaskProperty> getDesc() {
        return properties.get(TaskProperties.DESC);
    }

    @Override
    public Optional<TaskProperty> getVenue() {
        return properties.get(TaskProperties.VENUE);
    }

```
###### /java/seedu/manager/model/task/Task.java
``` java
    @Override
    public boolean matches(HashMap<TaskProperties, Optional<TaskProperty>> other) {
        for (TaskProperties property : TaskProperties.values()) {
            if (other.get(property).isPresent()) {
                if (!this.properties.get(property).isPresent()) {
                	if (!matchStartOrEndTime(other, property)) {
						return false;
					}
                } else if (!this.properties.get(property).get().matches(other.get(property).get())){
                    return false;
                }
            }
        }
        return true;
    }
    
    /**
     * Tries to match start time against end time in the case that this task doesn't have a start time
     * and vice versa 
     * @param other Other properties to compare against
     * @param property Property to compare on
     * @return true if property is start or end time and matches with this task, false otherwise
     */
    private boolean matchStartOrEndTime(HashMap<TaskProperties, Optional<TaskProperty>> other, TaskProperties property) {
    	if (property.equals(TaskProperties.STARTTIME)) {
			if (!(this.properties.get(TaskProperties.ENDTIME).isPresent() &&
					this.properties.get(TaskProperties.ENDTIME).get().matches(other.get(property).get()))) {
				return false;
			} else {
				return true;
			}
		} else if (property.equals(TaskProperties.ENDTIME)) {
			if (!(this.properties.get(TaskProperties.STARTTIME).isPresent() &&
					this.properties.get(TaskProperties.STARTTIME).get().matches(other.get(property).get()))) {
				return false;
			} else {
				return true;
			}
		} else {
			return false;
		}
    }
    
    @Override
    public int compareProperty(ReadOnlyTask other, TaskProperties property) {
    	assert other != null;
    	HashMap<TaskProperties, Optional<TaskProperty>> otherProps = other.getProperties();
    	
    	if (!this.properties.get(property).isPresent() && !otherProps.get(property).isPresent()) {
			return 0;
		} else if (!this.properties.get(property).isPresent()) {
			return 1;
		} else if (!otherProps.get(property).isPresent()) {
			return -1;
		} else {
			return this.properties.get(property).get().compareTo(otherProps.get(property).get());
		}
    }
    
```
###### /java/seedu/manager/model/task/TaskProperty.java
``` java
/**
 * An interface representing a property of a task
 *
 */
public abstract class TaskProperty implements Comparable<TaskProperty> {
    private String MESSAGE_CONSTRAINTS;
    private String VALIDATION_REGEX;
    
    /**
     * Create a TaskProperty given a string representing its value, a validation regex and a constraints message
     * @param property Value of the property. 
     * @param validationRegex Regex to validate against
     * @param messageConstraints Message with the constraints to show if property is not valid
     * @throws IllegalValueException
     */
    public TaskProperty(String property, String validationRegex, String messageConstraints) throws IllegalValueException {
        assert property != null;
        MESSAGE_CONSTRAINTS = messageConstraints;
        VALIDATION_REGEX = validationRegex;
        if (!isValid(property)) {
            throw new IllegalValueException(MESSAGE_CONSTRAINTS);
        }
    }
    
    /**
     * Tests whether a string is valid or not
     * @param test
     * @return Whether the string matches or not
     */
    public boolean isValid(String test) {
        return test.matches(VALIDATION_REGEX);
    }
    
    /**
     * Gets value of property as a string
     * @return Value as string
     */
    public String getValue() {
        return this.toString();
    }
    
    /**
     * Gets value of property as a pretty string, for displaying on the UI
     * @return Value as pretty string
     */
    public String getPrettyValue() {
        return this.toPrettyString();
    }
    
    public int hashCode() {
        return this.toString().hashCode();
    };
    
    public String getMessageConstraints() {
        return MESSAGE_CONSTRAINTS;
    };
    
    public abstract String toString();
    
    public String toPrettyString() {
    	return this.toString();
    }
    
    public abstract boolean equals(Object other);
    
    public int compareTo(TaskProperty other) {
    	return -1;
    }
    
```
###### /java/seedu/manager/model/task/Time.java
``` java
/**
 * Represents a tasks time 
 * Guarantees: immutable; is valid as declared in {@link #isValid(String)}
 */
public abstract class Time extends TaskProperty {
	public static final String MESSAGE_TIME_CONSTRAINTS =
            "Invalid Time. While times are quite flexible, don't forget that I'm just a computer. :)";
    public static final String TIME_VALIDATION_REGEX = ".+";
    
    private static final Pattern DATE_STRING_FORMAT_REGEX = 
    		Pattern.compile("([A-Z][a-z]{2} ){2}\\d{2} \\d{2}:\\d{2}:\\d{2} [A-Z]{3} \\d{4}");
    private static final DateFormat DATE_FORMAT = new SimpleDateFormat("EEE MMM dd kk:mm:ss zzz yyyy");
    private static final PrettyTimeParser timeParser = new PrettyTimeParser();
    private static final PrettyTime timePrettify = new PrettyTime();
    
    protected Date value;
    
    static {
    	DATE_FORMAT.setLenient(false);
    }
    
    /**
     * Parses and validates given time. If valid, assigns value to the time
     *
     * @throws IllegalValueException if given time string is invalid.
     */
    public Time(String time) throws IllegalValueException {
        super(time, TIME_VALIDATION_REGEX, MESSAGE_TIME_CONSTRAINTS);
        
        // To parse strings created by Date.toString()
        Matcher matcher = DATE_STRING_FORMAT_REGEX.matcher(time);
        if (matcher.matches()) {
			try {
				value = DATE_FORMAT.parse(time);
			} catch (ParseException e) {
				value = parseTime(time);
			}
		} else {
			value = parseTime(time);
		}
    }
    
    @Override
    public boolean isValid(String test) {
    	Matcher matcher = DATE_STRING_FORMAT_REGEX.matcher(test);
        if (matcher.matches()) {
			try {
				DATE_FORMAT.parse(test);
			} catch (ParseException e) {
				try {
					parseTime(test);
				} catch (IllegalValueException e1) {
					return false;
				}
			}
		} else {
			try {
				parseTime(test);
			} catch (IllegalValueException e) {
				return false;
			}
		}
        return true;
    };

    @Override
    public String toString() {
        return value.toString();
    }
    
    @Override
    public String toPrettyString() {
    	return timePrettify.format(value);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Time // instanceof handles nulls
                && this.value.equals(((Time) other).value)); // state check
    }
    
    /**
     * Parses the time string using PrettyTime
     * @param time Time to be parsed
     * @throws IllegalValueException
     */
    private Date parseTime(String time) throws IllegalValueException {
        List<Date> groups;
    	try {
    	    groups = timeParser.parse(time);
        } catch (Exception e) {
            throw new IllegalValueException("Invalid Time!");
        }
    	
    	if (groups.size() != 1) {
			throw new IllegalValueException(MESSAGE_TIME_CONSTRAINTS);
		}
    	return groups.get(0);
    }
    
    /**
```
###### /java/seedu/manager/model/task/Venue.java
``` java
    /**
     * Validates given venue.
     * @throws IllegalValueException if given venue string is invalid.
     */
    public Venue(String venue) throws IllegalValueException {
        super(venue, VENUE_VALIDATION_REGEX, MESSAGE_VENUE_CONSTRAINTS);
        value = venue;
    }

    @Override
    public String toString() {
        return value;
    }
    
    /**
```
###### /java/seedu/manager/model/UserPrefs.java
``` java
    public UserPrefs(){
        this.setGuiSettings(500, 500, 0, 0);
        this.setCommandWords(
        		new Commands[]{
        				Commands.ADD, Commands.EDIT, Commands.DELETE, Commands.UNDO, 
        				Commands.FIND, Commands.STORAGE, Commands.CLEAR, Commands.DONE, 
        				Commands.EXIT, Commands.HELP, Commands.LIST, Commands.SORT,
        				Commands.UNSORT, Commands.ALIAS
    				},
        		new String[]{
        				"add", "edit", "delete", "undo", 
        				"find", "storage", "clear", "done", 
        				"exit", "help", "list", "sort",
        				"unsort", "alias"
        			}
        		);
        this.setExtensionsWords(
        		new Commands[]{
        				Commands.BY, Commands.AT, Commands.EVENT, Commands.PRIORITY, 
        				Commands.TAG, Commands.VENUE
    				},
        		new String[]{
        				"by", "at", "from", "priority", 
        				"tag", "venue"
        			}
        		);
    }
    
```
###### /java/seedu/manager/model/UserPrefs.java
``` java
    /**
     * Get the keywords representing primary commands
     * @return Hashmap mapping from commands to keywords
     */
    public HashMap<Commands, String> getCommandWords() {
    	return commandWords;
    }
    
    /**
     * Get the keywords representing extensions
     * @return Hashmap mapping from commands to keywords
     */
    public HashMap<Commands, String> getExtensionsWords() {
    	return extensionWords;
    }
    
    /**
     * Gets the alias for a certain command
     * @param command Command for which alias will be returned 
     * @return Alias of the command
     */
    public String getAliasForCommand(Commands command) {
    	if (commandWords.containsKey(command)) {
			return commandWords.get(command);
		} else if (extensionWords.containsKey(command)) {
			return extensionWords.get(command);
		} else {
			assert false;
			return MESSAGE_NO_ALIAS; // should never reach this
		}
    }
    
    /**
     * Sets command words given 2 arrays representing the commands and their respective keywords
     * @param commands Array of commands
     * @param commandStrings Array of keywords
     */
    public void setCommandWords(Commands[] commands, String[] commandStrings) {
    	assert commands.length == commandStrings.length;
    	
		this.commandWords = new HashMap<>();
		for (int i = 0; i < commands.length; i++) {
			commandWords.put(commands[i], commandStrings[i]);
		}
	}
    
    /**
     * Sets extension words given 2 arrays representing the extensions and their respective keywords
     * @param commands Array of extensions
     * @param commandStrings Array of keywords
     */
    public void setExtensionsWords(Commands[] commands, String[] commandStrings) {
    	assert commands.length == commandStrings.length;
    	
    	this.extensionWords = new HashMap<>();
    	for (int i = 0; i < commands.length; i++) {
    		extensionWords.put(commands[i], commandStrings[i]);
    	}
    }
    
    /**
     * Change alias of a certain command
     * @param commandToChange Command whose alias will be changed
     * @param alias The new alias for the command
     * @param messageNoMatch Message used in error which will be thrown if there is no matching command
	 * @param messageAliasAlreadyTaken Message used in error which will be thrown if alias is already taken
     * @throws IllegalValueException
     */
    public void setSingleCommandWord(String commandToChange, String alias,
    		String messageNoMatch, String messageAliasAlreadyTaken) throws IllegalValueException {
    	
    	Commands matchedCommand = getMatchingCommand(commandToChange, messageNoMatch);
    	throwExceptionIfAliasAlreadyExists(matchedCommand, alias, messageAliasAlreadyTaken);
    	
    	if (commandWords.containsKey(matchedCommand)) {
    		commandWords.put(matchedCommand, alias);
		} else {
			extensionWords.put(matchedCommand, alias);
		}
		
    	EventsCenter.getInstance().post(new UserPrefsChangedEvent(this));
    }
    
    /**
     * Gets the command that matches with the input command
     * @param commandToChange Command that will be matched against
     * @param messageNoMatch Message used in error which will be thrown if there is no matching command 
     * @return Command which matches the input command
     * @throws IllegalValueException
     */
    private Commands getMatchingCommand(String commandToChange, String messageNoMatch) throws IllegalValueException {
    	for (Commands command : Commands.values()) {
			if (commandWords.containsKey(command) && commandWords.get(command).equals(commandToChange)) {
				return command;
			} else if (extensionWords.containsKey(command) && extensionWords.get(command).equals(commandToChange)) {
				return command;
			}
		}
    	
    	throw new IllegalValueException(messageNoMatch);
    }
    
    /**
     * Throws an exception if the alias has already been taken by a command other than the matched command
     * @param matchedCommand Command that user wants to alias
     * @param alias New alias for the command
     * @param messageAliasAlreadyTaken Message used in error which will be thrown if alias is already taken
     * @throws IllegalValueException
     */
    private void throwExceptionIfAliasAlreadyExists(Commands matchedCommand, String alias, String messageAliasAlreadyTaken)
    		throws IllegalValueException {
    	for (Commands command : Commands.values()) {
			if (!command.equals(matchedCommand)) {
				if (commandWords.containsKey(command) && commandWords.get(command).equals(alias)) {
					throw new IllegalValueException(String.format(messageAliasAlreadyTaken, command));
				} else if (extensionWords.containsKey(command) && extensionWords.get(command).equals(alias)) {
					throw new IllegalValueException(String.format(messageAliasAlreadyTaken, command));
				}
			}
		}
    }
    
```
###### /java/seedu/manager/storage/StorageManager.java
``` java
    @Subscribe
    /**
     * Save user preferences when they are changed
     * @param event Event indicating that the user preferences have changed
     * @throws IOException
     */
    public void handleUserPrefsChangedEvent(UserPrefsChangedEvent event) throws IOException {
    	saveUserPrefs(event.getUserPrefs());
    }

```
###### /java/seedu/manager/storage/StorageManager.java
``` java
    @Subscribe
    /**
     * Sets new file path when user wants to change the path
     * @param event Event indicating that the file path has changed
     */
    public void handleStorageLocationChangedEvent(StorageLocationChangedEvent event) {
    	logger.info(LogsCenter.getEventHandlingLogMessage(event, "Storage location changed, altering filepaths"));
    	setFilePath(event.getFilePath());
    }
    
```
###### /java/seedu/manager/ui/MainWindow.java
``` java
    /**
     * Gets the Tag List Panel
     */
    public TagListPanel getTagListPanel() {
        return this.tagListPanel;
    }
    
    /**
     * Rerender Status Bar Footer
     */
    public void rerenderStatusBarFooter() {
    	statusBarFooter = StatusBarFooter.load(primaryStage, getStatusbarPlaceholder(), config.getTaskManagerFilePath());
    }
}
```
###### /java/seedu/manager/ui/TaskCard.java
``` java
    /**
     * Colour overdue bar red if task is overdue
     */
    public void initTaskOverdue() {
        if (task.isTaskOverdue()) {
        	overdue.setStyle("-fx-background-color: red");
        }
    }
    
```
###### /java/seedu/manager/ui/UiManager.java
``` java
    @Subscribe
    /**
     * Scrolls to a tag when requested
     * @param event Event that requests jumping to a certain tag
     */
    private void handleJumpToTagListRequestEvent(JumpToTagListRequestEvent event) {
    	logger.info(LogsCenter.getEventHandlingLogMessage(event));
    	mainWindow.getTagListPanel().scrollTo(event.getTargetIndex());
    }
    
```
###### /java/seedu/manager/ui/UiManager.java
``` java
    @Subscribe
    /**
     * Updates file path on GUI when it is changed
     * @param event Event indicating that the file path has changed
     */
    public void handleConfigFilePathChangedEvent(ConfigFilePathChangedEvent event) {
    	logger.info(LogsCenter.getEventHandlingLogMessage(event, "Storage location changed, updating status bar"));
    	mainWindow.rerenderStatusBarFooter();
    }
}
```
###### /resources/view/TaskListCard.fxml
``` fxml
            <columnConstraints>
            	<ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="10.0" maxWidth="10.0" />
                <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="150.0" />
                <ColumnConstraints hgrow="SOMETIMES" maxWidth="100.0" minWidth="10.0" prefWidth="100.0" />
            </columnConstraints>
            <children>
            	<HBox alignment="CENTER_LEFT" fx:id="overdue" maxWidth="10.0" minWidth="10.0" prefWidth="10.0" GridPane.columnIndex="0">
                </HBox>
```
